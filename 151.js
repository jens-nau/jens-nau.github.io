(()=>{"use strict";var t,e,o={151:(t,e,o)=>{var r=o(975),s=o(160),i=o(333),n=o(945);const a=new Float64Array(16);function l(t,e,o){i.bA(a,o,-1),i.bI(e,a)<i.bI(e,o)?i.$X(t,e,a):i.$X(t,e,o)}const h=new Float64Array(16),d=Math.PI,c=2*d,u=d/2,f=Math.PI/180,g=1/f,p=new Float32Array(16),m=new Float32Array(16),F=new Float32Array(4),x=new Float32Array(3),E=new Set,w=[];let D=!1;class C{constructor(){this.name="",this.quaternion=new Float32Array([0,0,0,1]),this.position=new Float32Array(3),this.matrix=new Float32Array(16),r.yR(this.matrix),this.matrixWorld=new Float32Array(16),r.yR(this.matrixWorld),this.matrixNeedsUpdate=!1,this.matrixWorldNeedsUpdate=!1,this.parent=null,this.children=[]}setPosition(...t){const e=this.position;s.nI(e,t)>1e-10&&(e[0]=t[0],e[1]=t[1],e[2]=t[2],this.setMatrixNeedsUpdate())}setEuler(t,e,o){n.Su(F,t*g,e*g,o*g),this.setQuaternion(...F)}setQuaternion(...t){const e=this.quaternion;l(h,e,t),i.we(h)>1e-10&&(e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],this.setMatrixNeedsUpdate())}setWorldPosition(t,e,o){const i=this.parent;x[0]=t,x[1]=e,x[2]=o,i&&(i.updateMatrixWorld(),r.U_(p,i.matrixWorld),s.fF(x,x,p)),this.setPosition(...x)}setWorldEuler(t,e,o){n.Su(F,t*g,e*g,o*g),this.setWorldQuaternion(...F)}setWorldQuaternion(t,e,o,s){const i=this;F[0]=t,F[1]=e,F[2]=o,F[3]=s,i&&(i.updateMatrixWorld(),r.U_(p,i.matrixWorld),r.en(m,F),r.Jp(m,p,m),r.j6(F,m)),this.setQuaternion(...F)}getWorldPosition(t){this.updateMatrixWorld(),r.i0(t,this.matrixWorld)}getWorldQuaternion(t){this.updateMatrixWorld(),r.j6(t,this.matrixWorld)}traverseParents(t){let e;const o=D;D?e=new Set:(e=E,e.clear()),D=!0;let r=this.parent;for(;r&&!e.has(r);){if(t(r))return;e.add(r),r=r.parent}D=o,e.clear()}traverse(t){const e=D;let o,r;D?(o=new Set,r=[this]):(o=E,o.clear(),r=w,r[0]=this),D=!0;let s=0,i=1;for(;s<i;){const e=r[s];if(!t(e)){const t=e.children;for(let e=0,s=t.length;e<s;e++){const s=t[e];o.has(s)||(o.add(s),r[i]=s,i++)}}s++}D=e,o.clear(),r.fill(null)}find(t){let e=null;return this.traverse((o=>!!e||(t(o)?(e=o,!0):void 0))),e}addChild(t){if(t.parent)throw new Error("Frame: Added child must not already have a parent.");if(t===this)throw new Error("Frame: Frame cannot be added as a child to itself.");this.traverseParents((e=>{if(e===t)throw new Error("Frame: Added child is an ancestor of this Frame. Use Joint.makeClosure instead.")})),t.parent=this,this.children.push(t),t.setMatrixWorldNeedsUpdate()}removeChild(t){if(t.parent!==this)throw new Error("Frame: Child to be removed is not a child of this Frame.");const e=this.children.indexOf(t);this.children.splice(e,1),t.parent=null,t.setMatrixWorldNeedsUpdate()}attachChild(t){this.updateMatrixWorld(),t.updateMatrixWorld(),this.addChild(t),r.U_(p,this.matrixWorld),r.Jp(t.matrix,p,t.matrixWorld),r.i0(t.position,t.matrix),r.j6(t.quaternion,t.matrix)}detachChild(t){this.updateMatrixWorld(),t.updateMatrixWorld(),this.removeChild(t),r.JG(t.matrix,t.matrixWorld),r.i0(t.position,t.matrix),r.j6(t.quaternion,t.matrix)}computeMatrixWorld(){this.parent?r.Jp(this.matrixWorld,this.parent.matrixWorld,this.matrix):r.JG(this.matrixWorld,this.matrix)}setMatrixNeedsUpdate(){!1===this.matrixNeedsUpdate&&(this.matrixNeedsUpdate=!0,this.setMatrixWorldNeedsUpdate())}setMatrixWorldNeedsUpdate(){this.traverse((t=>!!t.matrixWorldNeedsUpdate||(t.matrixWorldNeedsUpdate=!0,!1)))}updateMatrix(){this.matrixNeedsUpdate&&(r.yl(this.matrix,this.quaternion,this.position),this.matrixNeedsUpdate=!1)}updateMatrixWorld(t=!1){const{parent:e}=this;this.matrixWorldNeedsUpdate&&(e&&e.matrixWorldNeedsUpdate&&e.updateMatrixWorld(!1),this.updateMatrix(),this.computeMatrixWorld(),this.matrixWorldNeedsUpdate=!1),t&&this.traverse((t=>{this!==t&&t.updateMatrixWorld(!1)}))}}function y(t){let e=t%c;return e>d?e-=c:e<=-d&&(e+=c),e}function v(t,e){let o=Math.round(t/c)*c+y(e);const r=o-t;return Math.abs(r)>d&&(o-=Math.sign(r)*c),o}function M(t,e,o){t[0]=v(e[0],o[0]),t[1]=v(e[1],o[1]),t[2]=v(e[2],o[2])}function J(t,e){return Math.abs(t[0]-e[0])+Math.abs(t[1]-e[1])+Math.abs(t[2]-e[2])}function A(t,e){t[0]=e[0]+d,t[1]=d-e[1],t[2]=e[2]+d}function b(t){const e=y(t[1]);return!(Math.abs(Math.abs(e)-u)>1e-7)}function V(t,e,o){if(!b(o))return!1;const r=y(o[1]),s=-1*Math.sign(r),i=o[0]+s*o[2];return t[0]=e[0],t[1]=v(e[1],o[1]),t[2]=v(e[2],s*(i-e[0])),M(t,e,t),!0}const S=new Float64Array(3),W=new Float64Array(3);function P(t,e,o){let r=1/0;if(b(o)){V(S,e,o),A(W,o),V(W,e,W);const i=J(e,S),n=J(e,W);i<n?(s.JG(t,S),r=i):(s.JG(t,W),r=n)}M(S,e,o),A(W,o),M(W,e,W);const i=J(e,S),n=J(e,W);(i<r||n<r)&&(i<n?s.JG(t,S):s.JG(t,W))}const T=new Float64Array(3),U=new Float64Array(4),k=new Float64Array(3),L=new Float64Array(4);function N(t,e,o,i){r.i0(T,t),r.j6(U,t),r.i0(k,e),r.j6(L,e),s.$X(o,T,k),l(i,U,L)}const _={X:0,Y:1,Z:2,EX:3,EY:4,EZ:5},R=Object.entries(_).sort(((t,e)=>t[1]-e[1])).map((t=>t[0])),X=new Float32Array(16),G=new Float32Array(16),I=new Float32Array(4),O=new Float32Array(3),Z=new Float32Array(3),Y=new Float32Array(3),j=new Float32Array(6);function Q(t,e){n.Su(I,e[_.EX]*g,e[_.EY]*g,e[_.EZ]*g),r.yl(t,I,e)}class q extends C{constructor(){super(),this.isJoint=!0,this.child=null,this.isClosure=!1,this.trackJointWrap=!1,this.rotationDoFCount=0,this.translationDoFCount=0,this.dof=[],this.dofFlags=new Uint8Array(6),this.dofValues=new Float32Array(6),this.dofTarget=new Float32Array(6),this.dofRestPose=new Float32Array(6),this.minDoFLimit=new Float32Array(6).fill(-1/0),this.maxDoFLimit=new Float32Array(6).fill(1/0),this.targetSet=!1,this.restPoseSet=!1,this.matrixDoFNeedsUpdate=!1,this.matrixDoF=new Float32Array(16),r.yR(this.matrixDoF),this.cachedIdentityDoFMatrixWorld=new Float32Array(16),r.yR(this.cachedIdentityDoFMatrixWorld)}_getQuaternion(t,e){n.Su(e,t[_.EX],t[_.EY],t[_.EZ])}_getEuler(t,e){e[0]=t[_.EX],e[1]=t[_.EY],e[2]=t[_.EZ]}_getPosition(t,e){e[0]=t[_.X],e[1]=t[_.Y],e[2]=t[_.Z]}_setValue(t,e,o){if(t===this.minDoFLimit||t==this.maxDoFLimit)throw new Error("Joint: Cannot set minDoFLimit or maxDoFLimit with _setValue.");if(e<0||e>6||"number"!=typeof e)throw new Error("Joint: Invalid DoF.");if(!this.dofFlags[e])return!1;const r=this.minDoFLimit[e],s=this.maxDoFLimit[e];return o<r&&(o=r),o>s&&(o=s),t[e]=o,o===s||o===r}_setValues(t,e){const o=this.dof;for(let r=0,s=e.length;r<s;r++)this._setValue(t,o[r],e[r])}_setViaFullPosition(t,e){const o=this.dofFlags;for(let r=0;r<3;r++)t[r]=o[r]*e[r]}_setViaFullEuler(t,e){const o=this.dofFlags;for(let r=3;r<6;r++)t[r]=o[r]*e[r-3];this.tryMinimizeEulerAngles()}_setViaQuaternion(t,e){if(function(t,e){const[o,r,s,i]=e,n=2*(i*o+r*s),a=1-2*(o*o+r*r),l=Math.atan2(n,a);let h=2*(i*r-s*o);h=h>1?1:h,h=h<-1?-1:h;const d=Math.asin(h),c=2*(i*s+o*r),u=1-2*(r*r+s*s),f=Math.atan2(c,u);t[0]=l*g,t[1]=d*g,t[2]=f*g}(Y,e),Y[0]*=f,Y[1]*=f,Y[2]*=f,this.trackJointWrap){const t=this.dofValues;O[0]=t[_.EX],O[1]=t[_.EY],O[2]=t[_.EZ],P(Y,O,Y)}this._setViaFullEuler(t,Y)}clearDoF(){this.setDoF()}setDoF(...t){t.forEach(((e,o)=>{if(e<0||e>=6)throw new Error("Joint: Invalid degree of freedom enum "+e+".");if(t.includes(e,o+1))throw new Error("Joint: Duplicate degree of freedom "+R[e]+"specified.");if(0!==o&&t[o-1]>e)throw new Error("Joint: Joints degrees of freedom must be specified in position then rotation, XYZ order")})),this.dof=t,this.dofValues.fill(0),this.dofTarget.fill(0),this.dofRestPose.fill(0),this.minDoFLimit.fill(-1/0),this.maxDoFLimit.fill(1/0),this.setMatrixDoFNeedsUpdate();for(let e=0;e<6;e++)this.dofFlags[e]=Number(t.includes(e));this.rotationDoFCount=this.dofFlags[_.EX]+this.dofFlags[_.EY]+this.dofFlags[_.EZ],this.translationDoFCount=this.dofFlags[_.X]+this.dofFlags[_.Y]+this.dofFlags[_.Z]}setDoFValues(...t){this.setMatrixDoFNeedsUpdate(),this._setValues(this.dofValues,t)}setDoFValue(t,e){return this.setMatrixDoFNeedsUpdate(),this._setValue(this.dofValues,t,e)}getDoFValue(t){return this.dofValues[t]}getDoFQuaternion(t){this._getQuaternion(this.dofValues,t)}getDoFEuler(t){this._getEuler(this.dofValues,t)}getDoFPosition(t){this._getPosition(this.dofValues,t)}setRestPoseValues(...t){this._setValues(this.dofRestPose,t)}setRestPoseValue(t,e){return this._setValue(this.dofRestPose,t,e)}getRestPoseValue(t){return this.dofRestPose[t]}getRestPoseQuaternion(t){this._getQuaternion(this.dofRestPose,t)}getRestPoseEuler(t){this._getEuler(this.dofRestPose,t)}getRestPosePosition(t){this._getPosition(this.dofRestPose,t)}setTargetValues(...t){this._setValues(this.dofTarget,t)}setTargetValue(t,e){this._setValue(this.dofTarget,t,e)}getTargetValue(t){return this.dofTarget[t]}getTargetQuaternion(t){this._getQuaternion(this.dofTarget,t)}getTargetEuler(t){this._getEuler(this.dofTarget,t)}getTargetPosition(t){this._getPosition(this.dofTarget,t)}setMinLimits(...t){const{dof:e}=this;for(const o in t){const r=e[o];this.setMinLimit(r,t[o])}}setMinLimit(t,e){this.minDoFLimit[t]=e,this.setDoFValue(t,this.dofValues[t])}getMinLimit(t){return this.minDoFLimit[t]}setMaxLimits(...t){const{dof:e}=this;for(const o in t){const r=e[o];this.setMaxLimit(r,t[o])}}setMaxLimit(t,e){this.maxDoFLimit[t]=e,this.setDoFValue(t,this.dofValues[t])}getMaxLimit(t){return this.maxDoFLimit[t]}getClosureError(t,e){if(!this.isClosure)throw new Error("Joint: Cannot get closure error on non closure Joint.");this.updateMatrixWorld(),this.child.updateMatrixWorld(),N(this.matrixWorld,this.child.matrixWorld,t,e)}tryMinimizeEulerAngles(){const{trackJointWrap:t,rotationDoFCount:e,dofRestPose:o,dofTarget:r,dofValues:s}=this;if(!t)if(e<3)for(let t=_.EX;t<=_.EZ;t++)r[t]=v(s[t],r[t]),o[t]=v(s[t],o[t]);else Z[0]=s[_.EX],Z[1]=s[_.EY],Z[2]=s[_.EZ],O[0]=r[_.EX],O[1]=r[_.EY],O[2]=r[_.EZ],P(O,Z,O),r[_.EX]=O[0],r[_.EY]=O[1],r[_.EZ]=O[2],O[0]=o[_.EX],O[1]=o[_.EY],O[2]=o[_.EZ],P(O,Z,O),o[_.EX]=O[0],o[_.EY]=O[1],o[_.EZ]=O[2]}getDeltaWorldMatrix(t,e,o){const{dofValues:s,minDoFLimit:i,maxDoFLimit:n,cachedIdentityDoFMatrixWorld:a}=this;this.updateMatrixWorld(),j.set(s);const l=i[t],h=n[t],d=j[t],c=d-l,u=h-d;let f=d+e;const g=e>0&&f>h&&c>u||e<0&&f<l&&u>c;return g&&(f=d-e),j[t]=f,Q(G,j),r.Jp(o,a,G),g}setMatrixDoFNeedsUpdate(){!1===this.matrixDoFNeedsUpdate&&(this.matrixDoFNeedsUpdate=!0,this.setMatrixWorldNeedsUpdate())}updateDoFMatrix(){this.matrixDoFNeedsUpdate&&(Q(this.matrixDoF,this.dofValues),this.matrixDoFNeedsUpdate=!1)}computeMatrixWorld(){const{parent:t,matrixWorld:e,matrix:o,matrixDoF:s,cachedIdentityDoFMatrixWorld:i}=this;this.updateDoFMatrix(),r.Jp(e,o,s),t?(r.Jp(e,t.matrixWorld,e),r.Jp(i,t.matrixWorld,o)):r.JG(i,o)}makeClosure(t){if(!t.isLink||this.child||t.parent===this)throw new Error("Joint: Given child cannot be used to make closure.");this.child=t,this.isClosure=!0,t.closureJoints.push(this)}addChild(t){if(!t.isLink||this.child||t.parent===this)throw new Error("Joint: Given child cannot be added to Joint.");super.addChild(t),this.child=t,this.isClosure=!1}removeChild(t){if(this.isClosure){if(this.child!==t)throw new Error("Frame: Child to be removed is not a child of this Joint.");{this.child=null,this.isClosure=!1;const e=t.closureJoints.indexOf(this);t.closureJoints.splice(e,1)}}else super.removeChild(t)}attachChild(t){super.attachChild(t),r.U_(X,this.matrixDoF),r.Jp(t.matrix,X,t.matrix),r.i0(t.position,t.matrix),r.j6(t.quaternion,t.matrix)}detachChild(t){super.detachChild(t),r.U_(X,this.matrixDoF),r.Jp(t.matrix,X,t.matrix),r.i0(t.position,t.matrix),r.j6(t.quaternion,t.matrix)}}const $=new Float64Array(3),z=new Float64Array(4),B=new Float64Array(3);function H(t,e,o,r=null,n={isConverged:!1,rowCount:7,totalError:0}){const{translationConvergeThreshold:a,rotationConvergeThreshold:l,translationErrorClamp:h,rotationErrorClamp:d,translationFactor:c,rotationFactor:u}=t,{translationDoFCount:f,rotationDoFCount:g,dofFlags:p,dof:m}=e;e.getClosureError($,z);let F=7;e.isGoal&&($[0]*=p[0],$[1]*=p[1],$[2]*=p[2],F=f,0===g?(z[0]=0,z[1]=0,z[2]=0,z[3]=0):F+=4);let x=!1,E=0;const w=s.kE($),D=i.kE(z);if(w<a&&D<l&&(x=!0),E+=w+D,r)if(w>h&&s.bA($,$,h/w),i.bA($,$,c),D>d&&i.bA(z,z,d/D),i.bA(z,z,u),e.isGoal){for(let t=0;t<f;t++){const e=m[t];r[o+t][0]=$[e]}3===e.rotationDoFCount&&(r[o+f+0][0]=z[0],r[o+f+1][0]=z[1],r[o+f+2][0]=z[2],r[o+f+3][0]=z[3])}else r[o+0][0]=$[0],r[o+1][0]=$[1],r[o+2][0]=$[2],r[o+3][0]=z[0],r[o+4][0]=z[1],r[o+5][0]=z[2],r[o+6][0]=z[3];return n.totalError=E,n.isConverged=x,n.rowCount=F,n}function K(t,e,o,r=null,i={isConverged:!1,rowCount:7,totalError:0}){const{translationConvergeThreshold:n,rotationConvergeThreshold:a,lockedJointDoFCount:l,translationErrorClamp:h,rotationErrorClamp:d,lockedJointDoF:c}=t,{dofTarget:u,dofValues:f,translationDoFCount:g,rotationDoFCount:p,translationFactor:m,rotationFactor:F,dofList:x}=e,E=s.TE(f,u);let w=u[_.EX]-f[_.EX]+u[_.EY]-f[_.EY]+u[_.EZ]-f[_.EZ];const D=l.get(e)||0;if(i.rowCount=g+p-D,i.isConverged=E<n&&w<a,i.totalError=E+w,r){const t=c.get(e),i=0!==D;let n=0;$[0]=u[0]-f[0],$[1]=u[1]-f[1],$[2]=u[2]-f[2];const a=s.kE($);s.bA($,$,m*h/a);for(let e=0,s=g;e<s;e++){const s=x[e];i&&t[s]||(r[o+n][0]=$[s],n++)}B[0]=e.dofTarget[3]-e.dofValues[3],B[1]=e.dofTarget[4]-e.dofValues[4],B[2]=e.dofTarget[5]-e.dofValues[5];const l=s.kE(B);s.bA(B,B,F*d/l);for(let e=g,s=g+p;e<s;e++){const s=x[e];i&&t[s]||(r[o+n][0]=B[s],n++)}}}var tt=o(399),et=o.n(tt),ot=o(409);function rt(t,e){const o=new Array(t);for(let r=0;r<t;r++)o[r]=new Float64Array(e);return o}function st(t,e){const o=e.length,r=e[0].length;for(let s=0;s<o;s++)for(let o=0;o<r;o++)t[s][o]=e[s][o]}function it(t){let e=0;const o=t.length,r=t[0].length;for(let s=0;s<o;s++)for(let o=0;o<r;o++)e+=t[s][o]**2;return e}function nt(t,e=3){const o=t.length,r=t[0].length;let s="";for(let i=0;i<o;i++){for(let o=0;o<r;o++)s+=t[i][o].toFixed(e)+", ";s+="\n"}return s}const at={transpose:function(t,e){const o=e.length,r=e[0].length;for(let s=0;s<o;s++)for(let o=0;o<r;o++)t[o][s]=e[s][o]},identity:function(t){for(let e=0,o=t.length;e<o;e++)for(let o=0,r=t.length;o<r;o++)t[e][o]=e===o?1:0},scale:function(t,e,o){for(let r=0,s=t.length;r<s;r++)for(let s=0,i=t.length;s<i;s++)t[r][s]=e[r][s]*o},multiply:function(t,e,o){if(e===t||o===t)throw new Error("Matrix: Cannot multiply to a matrix in place.");const r=e.length,s=o.length,i=o[0].length;for(let n=0,a=r;n<a;n++)for(let r=0,a=i;r<a;r++){let i=0;for(let t=0,a=s;t<a;t++)i+=e[n][t]*o[t][r];t[n][r]=i}},create:rt,copy:st,clone:function(t){const e=rt(t.length,t[0].length);return st(e,t),e},solve:function(t,e,o){const r=et().solve(e,o);for(let e=0,o=r.length;e<o;e++)t[e].set(r[e])},svd:function(t,e,o,r){const{u:s,v:i,q:n}=(0,ot.SVD)(r),a=s.length;for(let e=0;e<a;e++)t[e].set(s[e]);const l=i.length;for(let t=0;t<l;t++)o[t].set(i[t]);const h=n.length;for(let t=0;t<h;t++){const o=e[t],r=n[t];o.fill(0),o[t]=r}},invert:function(t,e){const o=et().invert(e),r=e[0].length,s=e.length;for(let e=0;e<r;e++)for(let r=0;r<s;r++)t[e][r]=o[e][r]},add:function(t,e,o){const r=e.length,s=e[0].length;for(let i=0;i<r;i++)for(let r=0;r<s;r++)t[i][r]=e[i][r]+o[i][r]},subtract:function(t,e,o){const r=e.length,s=e[0].length;for(let i=0;i<r;i++)for(let r=0;r<s;r++)t[i][r]=e[i][r]-o[i][r]},magnitudeSquared:it,magnitude:function(t){return Math.sqrt(it(t))},toString:nt,log:function(t,e){console.log(nt(t,e))}},lt=new Float64Array(16),ht=new Float64Array(16),dt=new Float64Array(16),ct=new Float64Array(16),ut=new Float64Array(4),ft=new Float64Array(3),gt=new Float64Array(4),pt=new Float64Array(3),mt=[],Ft=[],xt={rowCount:0,isConverged:!1,totalError:0},Et={errorRows:0,freeDoF:0,totalError:0},wt={CONVERGED:0,STALLED:1,DIVERGED:2,TIMEOUT:3};Object.entries(wt).sort(((t,e)=>t[1]-e[1])).map((t=>t[0]));class Dt{constructor(t){this.chain=Array.from(t),this.targets=null,this.affectedClosures=null,this.affectedConnectedClosures=null,this.lockedJointDoFCount=null,this.lockedJointDoF=null,this.prevDoFValues=null,this.maxIterations=-1,this.matrixPool=null,this.useSVD=!1,this.translationConvergeThreshold=-1,this.rotationConvergeThreshold=-1,this.translationFactor=-1,this.rotationFactor=-1,this.translationStep=-1,this.rotationStep=-1,this.translationErrorClamp=-1,this.rotationErrorClamp=-1,this.stallThreshold=-1,this.dampingFactor=-1,this.divergeThreshold=-1,this.restPoseFactor=-1,this.init()}init(){const t=this.chain,e=t.filter((t=>t.targetSet||t.isClosure)),o=new Map,r=new Map,s=new Map,i=new Map,n=new Map;t.forEach((t=>{i.set(t,new Set),n.set(t,new Set),o.set(t,new Uint8Array(6)),s.set(t,new Float64Array(6))})),e.forEach((t=>{if(t.isClosure){let e=t;for(;e;)e.isJoint&&i.get(e).add(t),e=e.parent;for(e=t.child;e;)e.isJoint&&n.get(e).add(t),e=e.parent}})),this.targets=e,this.affectedClosures=i,this.affectedConnectedClosures=n,this.lockedJointDoF=o,this.lockedJointDoFCount=r,this.prevDoFValues=s}solve(){const{divergeThreshold:t,stallThreshold:e,chain:o,restPoseFactor:r,lockedJointDoFCount:s,prevDoFValues:i,useSVD:n,matrixPool:a}=this;let l=0,h=1/0,d=-1;s.clear();for(let t=0,e=o.length;t<e;t++){const e=o[t];(e.targetSet||e.restPoseSet)&&e.tryMinimizeEulerAngles()}for(;;){a.releaseAll();for(let t=0,e=o.length;t<e;t++)o[t].updateMatrixWorld();mt.length=0,Ft.length=0,this.countUnconvergedVariables(Ft,mt,Et);const{freeDoF:s,errorRows:c,totalError:u}=Et;if(0===c){d=wt.CONVERGED;break}if(u>h+t){i.forEach(((t,e)=>{e.dofValues.set(t),e.setMatrixDoFNeedsUpdate()})),d=wt.DIVERGED;break}if(h=u,l++,l>this.maxIterations){d=wt.TIMEOUT;break}const f=a.get(c,1);this.fillErrorVector(mt,f);const g=a.get(c,s);this.fillJacobian(mt,Ft,g);const p=a.get(s,c);let m=!1;if(n)try{const t=c,e=s,o=Math.min(t,e),r=a.get(t,o),i=a.get(o,o),n=a.get(e,o);at.svd(r,i,n,g);const l=a.get(o,t),h=a.get(o,o);at.transpose(l,r);for(let t=0,e=i.length;t<e;t++){const e=i[t][t];let o;o=Math.abs(e)<.001?0:1/e,h[t][t]=o}const d=a.get(e,o);at.multiply(d,n,h),at.multiply(p,d,l)}catch(t){m=!0}if(!n||m){const t=a.get(c,c);at.identity(t),at.scale(t,t,this.dampingFactor**2);const e=a.get(s,c);at.transpose(e,g);const o=a.get(c,c);at.multiply(o,g,e);const r=a.get(c,c);at.add(r,o,t);const i=a.get(c,c);at.invert(i,r),at.multiply(p,e,i)}const F=a.get(s,1);if(at.multiply(F,p,f),0!==r){const t=a.get(s,1),e=a.get(s,1);let o=0;for(let e=0,r=Ft.length;e<r;e++){const r=Ft[e],s=this.lockedJointDoFCount.get(r)||0,i=0!==s,n=this.lockedJointDoF.get(r),a=r.rotationDoFCount+r.translationDoFCount-s;if(r.restPoseSet){const e=r.dof,s=r.dofValues,l=r.dofRestPose;for(let r=0;r<a;r++){const a=e[r];i&&n[a]||(t[o][0]=l[a]-s[a],o++)}}else for(let e=0;e<a;e++)t[o][0]=0,o++}const i=a.get(s,s);at.multiply(i,p,g);const n=a.get(s,s);at.identity(n);const l=a.get(s,s);at.subtract(l,n,i),at.multiply(e,l,t);for(let t=0;t<s;t++){const o=e[t][0];F[t][0]+=o*r}}if(e>0){let t=!0;for(let o=0,r=F.length;o<r;o++){const r=F[o][0];if(Math.abs(r)>e){t=!1;break}}if(t){d=wt.STALLED;break}}i.forEach(((t,e)=>{t.set(e.dofValues)})),this.applyJointAngles(Ft,F)}return mt.length=0,Ft.length=0,d}applyJointAngles(t,e){const{lockedJointDoF:o,lockedJointDoFCount:r}=this;let s=!1,i=0;for(let n=0,a=t.length;n<a;n++){const a=t[n],l=a.dof,h=o.get(a),d=r.has(a);for(let t=0,o=l.length;t<o;t++){const o=l[t];if(d&&h[o])continue;const n=a.getDoFValue(o);if(a.setDoFValue(o,n+e[i][0])){r.has(a)||(r.set(a,0),h.fill(0));const t=r.get(a);r.set(a,t+1),h[o]=1,s=!0}i++}}if(i!==e.length)throw new Error;return s}fillJacobian(t,e,o){const{translationStep:n,rotationStep:a,lockedJointDoF:l,lockedJointDoFCount:h,translationFactor:d,rotationFactor:c}=this,u=this.affectedClosures,f=this.affectedConnectedClosures;let g=0;for(let p=0,m=e.length;p<m;p++){const m=e[p],F=u.get(m),x=f.get(m),E=m.dof,w=m.translationDoFCount+m.rotationDoFCount,D=h.has(m),C=l.get(m);r.U_(ct,m.matrixWorld);for(let e=0;e<w;e++){const l=E[e];if(D&&C[l])continue;let h=0,u=l<3?n:a;m.getDeltaWorldMatrix(l,u,dt)&&(u*=-1);for(let e=0,n=t.length;e<n;e++){const n=t[e];if(n.isClosure)if(F.has(n)||x.has(n))if(n.getClosureError(ft,ut),x.has(n)?(r.Jp(lt,ct,n.child.matrixWorld),r.Jp(ht,dt,lt),N(n.matrixWorld,ht,pt,gt)):(r.Jp(lt,ct,n.matrixWorld),r.Jp(ht,dt,lt),N(ht,n.child.matrixWorld,pt,gt)),s.$X(ft,ft,pt),s.bA(ft,ft,d/u),i.$X(ut,ut,gt),i.bA(ut,ut,c/u),n.isGoal){const{translationDoFCount:t,rotationDoFCount:e,dof:r}=n;for(let e=0;e<t;e++){const t=r[e];o[h+e][g]=ft[t]}3===e&&(o[h+t+0][g]=ut[0],o[h+t+1][g]=ut[1],o[h+t+2][g]=ut[2],o[h+t+3][g]=ut[3],h+=4),h+=t}else o[h+0][g]=ft[0],o[h+1][g]=ft[1],o[h+2][g]=ft[2],o[h+3][g]=ut[0],o[h+4][g]=ut[1],o[h+5][g]=ut[2],o[h+6][g]=ut[3],h+=7;else{let t=7;n.isGoal&&(t=n.translationDoFCount,3===n.rotationDoFCount&&(t+=4));for(let e=0;e<t;e++)o[h+e][g]=0;h+=t}if(n.targetSet){const t=n.translationDoFCount+n.rotationDoFCount;if(m===n)for(let e=0;e<t;e++)o[h+g][g]=-1;else for(let e=0;e<t;e++)o[h+e][g]=0;h+=t}}g++}}if(g!==o[0].length)throw new Error}fillErrorVector(t,e){let o=0;for(let r=0,s=t.length;r<s;r++){const s=t[r];s.isClosure&&(H(this,s,o,e,xt),o+=xt.rowCount),s.targetSet&&(K(this,s,o,e,xt),o+=xt.rowCount)}}countUnconvergedVariables(t,e,o){const{lockedJointDoFCount:r}=this,s=this.chain;let i=0,n=0,a=0,l=0;for(let o=0,h=s.length;o<h;o++){let h=!1;const d=s[o],c=r.get(d)||0;d.isClosure&&(H(this,d,n,null,xt),xt.isConverged||(a+=xt.rowCount,i+=xt.totalError),h=!0,n+=xt.rowCount);const u=d.dof;d.targetSet&&(K(this,d,n,null,xt),xt.isConverged||(a+=xt.rowCount,i+=xt.totalError),h=!0,n+=xt.rowCount),!d.isGoal&&u.length>0&&(l+=u.length-c,t.push(d)),h&&e.push(d)}0===a&&(n=0),o.errorRows=n,o.freeDoF=l,o.totalError=i}}class Ct{constructor(t,e){const o=[];let r=0;this.get=function(){let s=o[r];return s||(o[r]=s=at.create(t,e)),r++,s},this.releaseAll=function(){r=0}}}class yt{constructor(){const t={},e=[];this.get=function(o,r){let s=t[o];s||(s=t[o]={});let i=s[r];return i||(i=s[r]=new Ct(o,r),e.push(i)),i.get()},this.releaseAll=function(){for(let t=0,o=e.length;t<o;t++)e[t].releaseAll()}}}class vt extends C{constructor(){super(),this.isLink=!0,this.closureJoints=[]}addChild(t){if(!t.isJoint)throw new Error("Link: Added child must be a Joint.");super.addChild(t)}}class Mt extends q{constructor(...t){super(...t),this.isGoal=!0,this.setFreeDoF()}setDoF(...t){let e=Number(t.includes(_.EX))+Number(t.includes(_.EY))+Number(t.includes(_.EZ));if(0!==e&&3!==e)throw new Error("Goal: Only full 3 DoF or 0 DoF rotation goals are supported.");super.setDoF(...t)}setGoalDoF(...t){this.setDoF(...t)}setFreeDoF(...t){const e=[_.X,_.Y,_.Z,_.EX,_.EY,_.EZ].filter((e=>!t.includes(e)));this.setDoF(...e)}addChild(){throw new Error("Goal: Cannot add children to Goal.")}}function Jt(t,e,o,r,s=!0,i=!0){const n=r/4;if(i){const{position:s,quaternion:i}=t;for(let t=0;t<3;t++)e[n+0+t]=s[t];for(let t=0;t<4;t++)e[n+3+t]=i[t];if(t.isJoint){const{dofTarget:s,dofRestPose:i,minDoFLimit:a,maxDoFLimit:l,targetSet:h,restPoseSet:d}=t;for(let t=0;t<6;t++)e[n+7+0+t]=s[t],e[n+7+6+t]=i[t],e[n+7+12+t]=a[t],e[n+7+18+t]=l[t];o[r+148]=Number(h),o[r+149]=Number(d)}}if(s&&t.isJoint){const{dofValues:o}=t;for(let t=0;t<6;t++)e[n+7+24+t]=o[t]}}function At(t,e,o,r,s=!0,i=!0){const n=r/4;if(i&&(t.setPosition(e[n+0],e[n+1],e[n+2]),t.setQuaternion(e[n+3+0],e[n+3+1],e[n+3+2],e[n+3+3]),t.isJoint)){const{dofTarget:s,dofRestPose:i,minDoFLimit:a,maxDoFLimit:l}=t;for(let t=0;t<6;t++)s[t]=e[n+7+0+t],i[t]=e[n+7+6+t],a[t]=e[n+7+12+t],l[t]=e[n+7+18+t];t.targetSet=Boolean(o[r+148]),t.restPoseSet=Boolean(o[r+149])}if(s&&t.isJoint){const{dofValues:o}=t;let r=!1;for(let t=0;t<6;t++){const s=e[n+7+24+t];s!==o[t]&&(o[t]=s,r=!0)}r&&t.setMatrixDoFNeedsUpdate()}}const bt="undefined"!=typeof SharedArrayBuffer;let Vt=new class{constructor(t=[]){this.matrixPool=new yt,this.useSVD=!1,this.maxIterations=5,this.stallThreshold=1e-4,this.dampingFactor=.001,this.divergeThreshold=.01,this.restPoseFactor=.01,this.translationConvergeThreshold=.001,this.rotationConvergeThreshold=1e-5,this.translationFactor=1,this.rotationFactor=1,this.translationStep=.001,this.rotationStep=.001,this.translationErrorClamp=.1,this.rotationErrorClamp=.1,this.roots=Array.isArray(t)?[...t]:[t],this.solvers=null,this.updateStructure()}updateStructure(){const t=function(t){const e=t.map((t=>{let e=t;return t.traverseParents((t=>{e=t})),e})),o=[],r=new Set;for(let t=0;t<e.length;t++){const s=e[t];r.has(s)||(o.push(s),s.traverse((t=>{if(r.has(t))return!0;let o;r.add(t),t.isLink?o=t.closureJoints:t.isJoint&&t.isClosure&&(o=[t.child]),o&&o.forEach((t=>{let o=t;t.traverseParents((t=>{o=t})),r.has(o)||e.push(o)}))})))}return o}(this.roots),e=[],o=new Set,r=new Set,s=t=>{if(t.isJoint){const s=t;if(o.add(s),s.isClosure){const t=new Set;let i=s.child;for(;i;){if(i.isJoint){if(o.has(i))break;t.add(i),r.add(i)}i=i.parent}o.forEach((e=>{t.add(e),r.add(e)})),e.push(t)}}const i=t.children;for(let t=0,e=i.length;t<e;t++)s(i[t]);o.delete(t)};t.forEach(s);const i=[];for(;e.length;){const t=e.pop();i.push(t);for(let o=0;o<e.length;o++){const r=e[o];let s=!1;r.forEach((e=>{s=s||t.has(e)})),s&&(r.forEach((e=>t.add(e))),e.splice(o,1),o--)}}const n=new Set;t.forEach((t=>t.traverse((t=>{t.isJoint&&t.dof.length>0&&!r.has(t)&&n.add(t)})))),this.solvers=i.map((t=>new Dt(t))),this.nonChainJoints=n}solve(){const{solvers:t,nonChainJoints:e}=this;e.forEach((t=>{t.targetSet&&(t.dofValues.set(t.dofTarget),t.setMatrixDoFNeedsUpdate())}));const o=[];for(let e=0,r=t.length;e<r;e++){const r=t[e];r.matrixPool=this.matrixPool,r.useSVD=this.useSVD,r.maxIterations=this.maxIterations,r.stallThreshold=this.stallThreshold,r.dampingFactor=this.dampingFactor,r.divergeThreshold=this.divergeThreshold,r.restPoseFactor=this.restPoseFactor,r.translationConvergeThreshold=this.translationConvergeThreshold,r.rotationConvergeThreshold=this.rotationConvergeThreshold,r.translationFactor=this.translationFactor,r.rotationFactor=this.rotationFactor,r.translationStep=this.translationStep,r.rotationStep=this.rotationStep,r.translationErrorClamp=this.translationErrorClamp,r.rotationErrorClamp=this.rotationErrorClamp;const s=r.solve();o.push(s)}return o}},St=-1,Wt=null,Pt=null,Tt=null,Ut=null;function kt(){!function(t,e,o,r=!0,s=!0){for(let i=0,n=t.length;i<n;i++)At(t[i],e,o,304*i,r,s)}(Wt,Tt,Ut,!1,!0);const t=Vt.solve();if(function(t,e,o,r=!0,s=!0){for(let i=0,n=t.length;i<n;i++)Jt(t[i],e,o,304*i,r,s)}(Wt,Tt,Ut,!0,!1),St=t.find((t=>t===wt.TIMEOUT))?setTimeout(kt):-1,bt)postMessage({type:"updateSolve",data:{status:t}});else{const e=Pt.slice();postMessage({type:"updateSolve",data:{status:t,buffer:e}},[e])}}o.g.onmessage=function({data:t}){const{type:e,data:o}=t;switch(e){case"updateStructure":Wt=function(t){const e=t.map((t=>{const{type:e,name:o,position:r,quaternion:s,dof:i,dofValues:n,dofTarget:a,dofRestPose:l,minDoFLimit:h,maxDoFLimit:d,targetSet:c,restPoseSet:u,isClosure:f}=t;let g;switch(e){case"Goal":case"Joint":g="Goal"===e?new Mt:new q,g.setDoF(...i),g.dofValues.set(n),g.dofTarget.set(a),g.dofRestPose.set(l),g.minDoFLimit.set(h),g.maxDoFLimit.set(d),g.targetSet=c,g.restPoseSet=u,g.isClosure=f;break;case"Link":g=new vt}return g.name=o,g.position.set(r),g.quaternion.set(s),g}));for(let o=0;o<e.length;o++){const r=e[o],s=t[o];r.parent=e[s.parent]||null,r.children.push(...s.children.map((t=>e[t]))),r.setMatrixNeedsUpdate(),r.isLink&&r.closureJoints.push(...s.closureJoints.map((t=>e[t]))),r.isJoint&&(r.child=null!==s.child?e[s.child]:null,r.setMatrixDoFNeedsUpdate())}return e}(o.serialized),Vt.roots=Wt.filter((t=>null===t.parent)),Vt.updateStructure(),Pt=o.buffer,Ut=new Uint8Array(Pt),Tt=new Float32Array(Pt);break;case"updateFrameState":Ut.set(new Uint8Array(o.buffer));break;case"updateSolverSettings":Object.assign(Vt,o);break;case"startSolve":-1===St&&kt();break;case"endSolve":-1!==St&&(clearTimeout(St),St=-1)}}}},r={};function s(t){var e=r[t];if(void 0!==e)return e.exports;var i=r[t]={exports:{}};return o[t].call(i.exports,i,i.exports,s),i.exports}s.m=o,s.x=()=>{var t=s.O(void 0,[555],(()=>s(151)));return s.O(t)},t=[],s.O=(e,o,r,i)=>{if(!o){var n=1/0;for(h=0;h<t.length;h++){for(var[o,r,i]=t[h],a=!0,l=0;l<o.length;l++)(!1&i||n>=i)&&Object.keys(s.O).every((t=>s.O[t](o[l])))?o.splice(l--,1):(a=!1,i<n&&(n=i));a&&(t.splice(h--,1),e=r())}return e}i=i||0;for(var h=t.length;h>0&&t[h-1][2]>i;h--)t[h]=t[h-1];t[h]=[o,r,i]},s.n=t=>{var e=t&&t.__esModule?()=>t.default:()=>t;return s.d(e,{a:e}),e},s.d=(t,e)=>{for(var o in e)s.o(e,o)&&!s.o(t,o)&&Object.defineProperty(t,o,{enumerable:!0,get:e[o]})},s.f={},s.e=t=>Promise.all(Object.keys(s.f).reduce(((e,o)=>(s.f[o](t,e),e)),[])),s.u=t=>t+".js",s.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(t){if("object"==typeof window)return window}}(),s.o=(t,e)=>Object.prototype.hasOwnProperty.call(t,e),(()=>{var t;s.g.importScripts&&(t=s.g.location+"");var e=s.g.document;if(!t&&e&&(e.currentScript&&(t=e.currentScript.src),!t)){var o=e.getElementsByTagName("script");o.length&&(t=o[o.length-1].src)}if(!t)throw new Error("Automatic publicPath is not supported in this browser");t=t.replace(/#.*$/,"").replace(/\?.*$/,"").replace(/\/[^\/]+$/,"/"),s.p=t})(),(()=>{var t={151:1};s.f.i=(e,o)=>{t[e]||importScripts(s.p+s.u(e))};var e=self.webpackChunkrv=self.webpackChunkrv||[],o=e.push.bind(e);e.push=e=>{var[r,i,n]=e;for(var a in i)s.o(i,a)&&(s.m[a]=i[a]);for(n&&n(s);r.length;)t[r.pop()]=1;o(e)}})(),e=s.x,s.x=()=>s.e(555).then(e),s.x()})();
//# sourceMappingURL=151.js.map