{"version":3,"sources":["webpack://rv/webpack/runtime/chunk loaded","webpack://rv/webpack/runtime/startup chunk dependencies","webpack://rv/./additional_modules/closed-chain-ik/core/utils/quaternion.js","webpack://rv/./additional_modules/closed-chain-ik/core/utils/constants.js","webpack://rv/./additional_modules/closed-chain-ik/core/Frame.js","webpack://rv/./additional_modules/closed-chain-ik/core/utils/euler.js","webpack://rv/./additional_modules/closed-chain-ik/core/utils/glmatrix.js","webpack://rv/./additional_modules/closed-chain-ik/core/Joint.js","webpack://rv/./additional_modules/closed-chain-ik/core/utils/solver.js","webpack://rv/./additional_modules/closed-chain-ik/core/utils/matrix.js","webpack://rv/./additional_modules/closed-chain-ik/core/ChainSolver.js","webpack://rv/./additional_modules/closed-chain-ik/core/MatrixPool.js","webpack://rv/./additional_modules/closed-chain-ik/core/Link.js","webpack://rv/./additional_modules/closed-chain-ik/core/Goal.js","webpack://rv/./additional_modules/closed-chain-ik/worker/utils.js","webpack://rv/./additional_modules/closed-chain-ik/worker/workerSolver.worker.js","webpack://rv/./additional_modules/closed-chain-ik/core/Solver.js","webpack://rv/./additional_modules/closed-chain-ik/core/utils/findRoots.js","webpack://rv/./additional_modules/closed-chain-ik/worker/serialize.js","webpack://rv/webpack/bootstrap","webpack://rv/webpack/runtime/compat get default export","webpack://rv/webpack/runtime/define property getters","webpack://rv/webpack/runtime/ensure chunk","webpack://rv/webpack/runtime/get javascript chunk filename","webpack://rv/webpack/runtime/global","webpack://rv/webpack/runtime/hasOwnProperty shorthand","webpack://rv/webpack/runtime/publicPath","webpack://rv/webpack/runtime/importScripts chunk loading","webpack://rv/webpack/startup"],"names":["deferred","next","tempQuat","Float64Array","smallestDifferenceQuaternion","output","a","b","vec4","tempQuat2","PI","Math","PI2","HALF_PI","DEG2RAD","RAD2DEG","tempInverse","Float32Array","tempMatrix","tempPos","sharedTraversedChildren","Set","sharedTraverseArray","traverseVariablesInUse","Frame","constructor","this","name","quaternion","position","matrix","mat4","matrixWorld","matrixNeedsUpdate","matrixWorldNeedsUpdate","parent","children","setPosition","args","vec3","setMatrixNeedsUpdate","setEuler","x","y","z","quat","setQuaternion","setWorldPosition","updateMatrixWorld","setWorldEuler","setWorldQuaternion","w","getWorldPosition","arr","getWorldQuaternion","traverseParents","cb","traversedChildren","originalVariablesInUse","clear","curr","has","add","traverse","stack","i","tot","c","l","length","child","fill","find","result","addChild","Error","p","push","setMatrixWorldNeedsUpdate","removeChild","index","indexOf","splice","attachChild","detachChild","computeMatrixWorld","updateMatrix","updateChildren","clampEulerValue","value","toSmallestEulerValueDistance","target","toAdjust","round","delta","abs","sign","toSmallestEulerDistance","diffEulerDistance","getRedundantEulerRepresentation","input","isRedundantTwist","euler","pivotAngle","toSmallestRedundantTwistRepresentation","zRotationSign","combinedXRotation","tempEuler1","tempEuler2","getClosestEulerRepresentation","score","Infinity","d1","d2","tempPos2","getMatrixDifference","outPos","outQuat","DOF","X","Y","Z","EX","EY","EZ","DOF_NAMES","Object","entries","sort","map","e","tempEuler","tempValueEuler","quatEuler","tempDoFValues","dofToMatrix","out","dof","Joint","super","isJoint","isClosure","trackJointWrap","rotationDoFCount","translationDoFCount","dofFlags","Uint8Array","dofValues","dofTarget","dofRestPose","minDoFLimit","maxDoFLimit","targetSet","restPoseSet","matrixDoFNeedsUpdate","matrixDoF","cachedIdentityDoFMatrixWorld","_getQuaternion","_getEuler","outEuler","_getPosition","_setValue","minVal","maxVal","_setValues","values","_setViaFullPosition","_setViaFullEuler","tryMinimizeEulerAngles","_setViaQuaternion","t0","t1","roll","atan2","t2","pitch","asin","t3","t4","yaw","getEuler","clearDoF","setDoF","forEach","includes","setMatrixDoFNeedsUpdate","Number","setDoFValues","setDoFValue","getDoFValue","getDoFQuaternion","getDoFEuler","getDoFPosition","setRestPoseValues","setRestPoseValue","getRestPoseValue","getRestPoseQuaternion","getRestPoseEuler","getRestPosePosition","setTargetValues","setTargetValue","getTargetValue","getTargetQuaternion","getTargetEuler","getTargetPosition","setMinLimits","d","setMinLimit","getMinLimit","setMaxLimits","setMaxLimit","getMaxLimit","getClosureError","getDeltaWorldMatrix","outMatrix","set","min","max","currVal","minSlack","maxSlack","newVal","doInvert","updateDoFMatrix","makeClosure","isLink","closureJoints","accumulateClosureError","solver","joint","startIndex","errorVector","isConverged","rowCount","totalError","translationConvergeThreshold","rotationConvergeThreshold","translationErrorClamp","rotationErrorClamp","translationFactor","rotationFactor","isGoal","posMag","rotMag","accumulateTargetError","lockedJointDoFCount","lockedJointDoF","dofList","posDelta","rotDelta","lockedDoFCount","get","lockedDoF","isLocked","rowIndex","eulerMag","create","row","col","Array","copy","sourceMatrix","tr","tc","r","magnitudeSquared","sum","rows","cols","toString","dec","str","toFixed","mat","transpose","identity","scale","scalar","multiply","m","n","k","ti","clone","resultMatrix","solve","vector","res","linearSolve","svd","ru","rq","rv","u","v","q","SVD","urows","vrows","qrows","rqrow","qval","invert","subtract","magnitude","sqrt","log","console","targetRelativeToJointMatrix","targetDeltaWorldMatrix","tempDeltaWorldMatrix","tempInverseMatrixWorld","targetJoints","freeJoints","errorResultInfo","dofResultInfo","errorRows","freeDoF","SOLVE_STATUS","CONVERGED","STALLED","DIVERGED","TIMEOUT","el","ChainSolver","chain","from","targets","affectedClosures","affectedConnectedClosures","prevDoFValues","maxIterations","matrixPool","useSVD","translationStep","rotationStep","stallThreshold","dampingFactor","divergeThreshold","restPoseFactor","init","filter","j","Map","currJoint","iterations","prevErrorMagnitude","status","releaseAll","countUnconvergedVariables","fillErrorVector","jacobian","fillJacobian","pseudoInverse","failedSVD","uTranspose","qInverse","val","inv","vqinv","err","jacobianIdentityDamping","jacobianTranspose","jjt","jjti","jjtii","deltaTheta","restPose","restPoseResult","colIndex","colCount","jij","ident","nullSpaceProjection","stalled","applyJointAngles","lockedJoint","dti","lockedCount","outJacobian","freeJoint","relevantClosures","relevantConnectedClosures","co","targetJoint","totalRows","unconvergedRows","addToTargetList","FixedMatrixPool","matrices","MatrixPool","pools","poolArray","colPools","pool","Link","Goal","setFreeDoF","rotCount","setGoalDoF","copyFrameToBuffer","frame","floatBuffer","byteBuffer","byteOffset","copyDoFValues","copyJointSettings","floatOffset","copyBufferToFrame","Boolean","changed","useSharedArrayBuffers","SharedArrayBuffer","roots","isArray","solvers","updateStructure","frames","potentialRoots","f","lastParent","closureConnections","cl","findRoots","chains","traversal","allChainJoints","traverseChains","chainSet","delete","independentChains","currChain","pop","otherChain","dependent","nonChainJoints","root","results","s","solveHandle","buffer","updateSolve","applyFromBuffer","applyToBuffer","setTimeout","postMessage","type","data","resultsBuffer","slice","global","onmessage","info","deserialize","serialized","assign","clearTimeout","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","exports","module","__webpack_modules__","call","__webpack_exports__","O","chunkIds","fn","priority","notFulfilled","fulfilled","keys","every","key","getter","__esModule","definition","o","defineProperty","enumerable","chunkId","Promise","all","reduce","promises","g","globalThis","Function","window","obj","prop","prototype","hasOwnProperty","scriptUrl","importScripts","location","document","currentScript","src","scripts","getElementsByTagName","replace","installedChunks","151","chunkLoadingGlobal","self","parentChunkLoadingFunction","bind","moreModules","runtime","then"],"mappings":"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","file":"151.js","sourcesContent":["var deferred = [];\n__webpack_require__.O = (result, chunkIds, fn, priority) => {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar [chunkIds, fn, priority] = deferred[i];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tresult = fn();\n\t\t}\n\t}\n\treturn result;\n};","var next = __webpack_require__.x;\n__webpack_require__.x = () => {\n\treturn __webpack_require__.e(555).then(next);\n};","import { vec4 } from 'gl-matrix';\n\nconst tempQuat = new Float64Array( 16 );\nexport function smallestDifferenceQuaternion( output, a, b ) {\n\n\t// inverting all values yields the same rotation\n\tvec4.scale( tempQuat, b, - 1 );\n\n\t// return the quat that represents the smallest difference\n\tif ( vec4.squaredDistance( a, tempQuat ) < vec4.squaredDistance( a, b ) ) {\n\n\t\tvec4.subtract( output, a, tempQuat );\n\n\t} else {\n\n\t\tvec4.subtract( output, a, b );\n\n\t}\n\n}\n\nconst tempQuat2 = new Float64Array( 16 );\nexport function quaternionDistance( a, b ) {\n\n\tsmallestDifferenceQuaternion( tempQuat2, a, b );\n\treturn vec4.length( tempQuat2 );\n\n}\n\nexport function quaternionSquaredDistance( a, b ) {\n\n\tsmallestDifferenceQuaternion( tempQuat2, a, b );\n\treturn vec4.squaredLength( tempQuat2 );\n\n}\n","const PI = Math.PI;\nconst PI2 = 2 * PI;\nconst HALF_PI = PI / 2;\nconst DEG2RAD = Math.PI / 180;\nconst RAD2DEG = 1 / DEG2RAD;\n\nexport { PI, PI2, HALF_PI, DEG2RAD, RAD2DEG };\n","import { mat4, quat, vec3 } from 'gl-matrix';\nimport { quaternionSquaredDistance } from './utils/quaternion.js';\nimport { RAD2DEG } from './utils/constants.js';\n\nconst tempInverse = new Float32Array( 16 );\nconst tempMatrix = new Float32Array( 16 );\nconst tempQuat = new Float32Array( 4 );\nconst tempPos = new Float32Array( 3 );\nconst sharedTraversedChildren = new Set();\nconst sharedTraverseArray = [];\nlet traverseVariablesInUse = false;\n\nexport class Frame {\n\n\tconstructor() {\n\n\t\tthis.name = '';\n\n\t\tthis.quaternion = new Float32Array( [ 0, 0, 0, 1 ] );\n\t\tthis.position = new Float32Array( 3 );\n\n\t\tthis.matrix = new Float32Array( 16 );\n\t\tmat4.identity( this.matrix );\n\n\t\tthis.matrixWorld = new Float32Array( 16 );\n\t\tmat4.identity( this.matrixWorld );\n\n\t\tthis.matrixNeedsUpdate = false;\n\t\tthis.matrixWorldNeedsUpdate = false;\n\n\t\tthis.parent = null;\n\t\tthis.children = [];\n\n\t}\n\n\tsetPosition( ...args ) {\n\n\t\tconst position = this.position;\n\n\t\tif ( vec3.sqrDist( position, args ) > 1e-10 ) {\n\n\t\t\tposition[ 0 ] = args[ 0 ];\n\t\t\tposition[ 1 ] = args[ 1 ];\n\t\t\tposition[ 2 ] = args[ 2 ];\n\t\t\tthis.setMatrixNeedsUpdate();\n\n\t\t}\n\n\t}\n\n\tsetEuler( x, y, z ) {\n\n\t\tquat.fromEuler( tempQuat, x * RAD2DEG, y * RAD2DEG, z * RAD2DEG );\n\t\tthis.setQuaternion( ...tempQuat );\n\n\t}\n\n\tsetQuaternion( ...args ) {\n\n\t\tconst quaternion = this.quaternion;\n\t\tif ( quaternionSquaredDistance( quaternion, args ) > 1e-10 ) {\n\n\t\t\tquaternion[ 0 ] = args[ 0 ];\n\t\t\tquaternion[ 1 ] = args[ 1 ];\n\t\t\tquaternion[ 2 ] = args[ 2 ];\n\t\t\tquaternion[ 3 ] = args[ 3 ];\n\t\t\tthis.setMatrixNeedsUpdate();\n\n\t\t}\n\n\t}\n\n\tsetWorldPosition( x, y, z ) {\n\n\t\tconst parent = this.parent;\n\n\t\ttempPos[ 0 ] = x;\n\t\ttempPos[ 1 ] = y;\n\t\ttempPos[ 2 ] = z;\n\n\t\tif ( parent ) {\n\n\t\t\tparent.updateMatrixWorld();\n\t\t\tmat4.invert( tempInverse, parent.matrixWorld );\n\t\t\tvec3.transformMat4( tempPos, tempPos, tempInverse );\n\n\t\t}\n\n\t\tthis.setPosition( ...tempPos );\n\n\t}\n\n\tsetWorldEuler( x, y, z ) {\n\n\t\tquat.fromEuler( tempQuat, x * RAD2DEG, y * RAD2DEG, z * RAD2DEG );\n\t\tthis.setWorldQuaternion( ...tempQuat );\n\n\t}\n\n\tsetWorldQuaternion( x, y, z, w ) {\n\n\t\tconst parent = this;\n\n\t\ttempQuat[ 0 ] = x;\n\t\ttempQuat[ 1 ] = y;\n\t\ttempQuat[ 2 ] = z;\n\t\ttempQuat[ 3 ] = w;\n\n\t\tif ( parent ) {\n\n\t\t\tparent.updateMatrixWorld();\n\t\t\tmat4.invert( tempInverse, parent.matrixWorld );\n\t\t\tmat4.fromQuat( tempMatrix, tempQuat );\n\t\t\tmat4.multiply( tempMatrix, tempInverse, tempMatrix );\n\t\t\tmat4.getRotation( tempQuat, tempMatrix );\n\n\t\t}\n\n\t\tthis.setQuaternion( ...tempQuat );\n\n\t}\n\n\tgetWorldPosition( arr ) {\n\n\t\tthis.updateMatrixWorld();\n\t\tmat4.getTranslation( arr, this.matrixWorld );\n\n\t}\n\n\tgetWorldQuaternion( arr ) {\n\n\t\tthis.updateMatrixWorld();\n\t\tmat4.getRotation( arr, this.matrixWorld );\n\n\t}\n\n\ttraverseParents( cb ) {\n\n\t\t// Use the shared variables if they're not already in use to avoid\n\t\t// memory allocation\n\t\tlet traversedChildren;\n\t\tconst originalVariablesInUse = traverseVariablesInUse;\n\t\tif ( traverseVariablesInUse ) {\n\n\t\t\ttraversedChildren = new Set();\n\n\t\t} else {\n\n\t\t\ttraversedChildren = sharedTraversedChildren;\n\t\t\ttraversedChildren.clear();\n\n\t\t}\n\n\t\ttraverseVariablesInUse = true;\n\n\t\tlet curr = this.parent;\n\t\twhile ( curr ) {\n\n\t\t\tif ( traversedChildren.has( curr ) ) {\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tconst stop = cb( curr );\n\t\t\tif ( stop ) {\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\ttraversedChildren.add( curr );\n\t\t\tcurr = curr.parent;\n\n\t\t}\n\n\t\ttraverseVariablesInUse = originalVariablesInUse;\n\t\ttraversedChildren.clear();\n\n\t}\n\n\ttraverse( cb ) {\n\n\t\t// Use the shared variables if they're not already in use to avoid\n\t\t// memory allocation\n\t\tconst originalVariablesInUse = traverseVariablesInUse;\n\t\tlet traversedChildren;\n\t\tlet stack;\n\t\tif ( traverseVariablesInUse ) {\n\n\t\t\ttraversedChildren = new Set();\n\t\t\tstack = [ this ];\n\n\t\t} else {\n\n\t\t\ttraversedChildren = sharedTraversedChildren;\n\t\t\ttraversedChildren.clear();\n\n\t\t\tstack = sharedTraverseArray;\n\t\t\tstack[ 0 ] = this;\n\n\t\t}\n\n\t\ttraverseVariablesInUse = true;\n\n\t\tlet i = 0;\n\t\tlet tot = 1;\n\t\twhile ( i < tot ) {\n\n\t\t\tconst curr = stack[ i ];\n\t\t\tconst stop = cb( curr );\n\t\t\tif ( ! stop ) {\n\n\t\t\t\tconst children = curr.children;\n\t\t\t\tfor ( let c = 0, l = children.length; c < l; c ++ ) {\n\n\t\t\t\t\tconst child = children[ c ];\n\t\t\t\t\tif ( traversedChildren.has( child ) ) {\n\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\ttraversedChildren.add( child );\n\t\t\t\t\t\tstack[ tot ] = child;\n\t\t\t\t\t\ttot ++;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\ti ++;\n\n\t\t}\n\n\t\ttraverseVariablesInUse = originalVariablesInUse;\n\t\ttraversedChildren.clear();\n\t\tstack.fill( null );\n\n\t}\n\n\tfind( cb ) {\n\n\t\tlet result = null;\n\t\tthis.traverse( c => {\n\n\t\t\tif ( result ) {\n\n\t\t\t\treturn true;\n\n\t\t\t} else if ( cb( c ) ) {\n\n\t\t\t\tresult = c;\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t} );\n\t\treturn result;\n\n\t}\n\n\taddChild( child ) {\n\n\t\tif ( child.parent ) {\n\n\t\t\tthrow new Error( 'Frame: Added child must not already have a parent.' );\n\n\t\t}\n\n\t\tif ( child === this ) {\n\n\t\t\tthrow new Error( 'Frame: Frame cannot be added as a child to itself.' );\n\n\t\t}\n\n\t\tthis.traverseParents( p => {\n\n\t\t\tif ( p === child ) {\n\n\t\t\t\tthrow new Error( 'Frame: Added child is an ancestor of this Frame. Use Joint.makeClosure instead.' );\n\n\t\t\t}\n\n\t\t} );\n\n\t\tchild.parent = this;\n\t\tthis.children.push( child );\n\n\t\tchild.setMatrixWorldNeedsUpdate();\n\n\t}\n\n\tremoveChild( child ) {\n\n\t\tif ( child.parent !== this ) {\n\n\t\t\tthrow new Error( 'Frame: Child to be removed is not a child of this Frame.' );\n\n\t\t}\n\n\t\tconst index = this.children.indexOf( child );\n\n\t\tthis.children.splice( index, 1 );\n\t\tchild.parent = null;\n\n\t\tchild.setMatrixWorldNeedsUpdate();\n\n\t}\n\n\tattachChild( child ) {\n\n\t\tthis.updateMatrixWorld();\n\t\tchild.updateMatrixWorld();\n\n\t\tthis.addChild( child );\n\n\t\tmat4.invert( tempInverse, this.matrixWorld );\n\t\tmat4.multiply( child.matrix, tempInverse, child.matrixWorld );\n\t\tmat4.getTranslation( child.position, child.matrix );\n\t\tmat4.getRotation( child.quaternion, child.matrix );\n\n\t}\n\n\tdetachChild( child ) {\n\n\t\tthis.updateMatrixWorld();\n\t\tchild.updateMatrixWorld();\n\n\t\tthis.removeChild( child );\n\n\t\tmat4.copy( child.matrix, child.matrixWorld );\n\t\tmat4.getTranslation( child.position, child.matrix );\n\t\tmat4.getRotation( child.quaternion, child.matrix );\n\n\t}\n\n\tcomputeMatrixWorld() {\n\n\t\tif ( this.parent ) {\n\n\t\t\tmat4.multiply( this.matrixWorld, this.parent.matrixWorld, this.matrix );\n\n\t\t} else {\n\n\t\t\tmat4.copy( this.matrixWorld, this.matrix );\n\n\t\t}\n\n\t}\n\n\tsetMatrixNeedsUpdate() {\n\n\t\tif ( this.matrixNeedsUpdate === false ) {\n\n\t\t\tthis.matrixNeedsUpdate = true;\n\t\t\tthis.setMatrixWorldNeedsUpdate();\n\n\t\t}\n\n\t}\n\n\tsetMatrixWorldNeedsUpdate() {\n\n\t\tthis.traverse( c => {\n\n\t\t\tif ( c.matrixWorldNeedsUpdate ) {\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t\tc.matrixWorldNeedsUpdate = true;\n\t\t\treturn false;\n\n\t\t} );\n\n\t}\n\n\tupdateMatrix() {\n\n\t\tif ( this.matrixNeedsUpdate ) {\n\n\t\t\tmat4.fromRotationTranslation( this.matrix, this.quaternion, this.position );\n\t\t\tthis.matrixNeedsUpdate = false;\n\n\t\t}\n\n\t}\n\n\tupdateMatrixWorld( updateChildren = false ) {\n\n\t\tconst { parent } = this;\n\n\t\tif ( this.matrixWorldNeedsUpdate ) {\n\n\t\t\t// Climb the parent chain and update parent matrices\n\t\t\tif ( parent && parent.matrixWorldNeedsUpdate ) {\n\n\t\t\t\tparent.updateMatrixWorld( false );\n\n\t\t\t}\n\n\t\t\t// Update this matrix\n\t\t\tthis.updateMatrix();\n\n\t\t\t// Update this matrix world and dirty children\n\t\t\tthis.computeMatrixWorld();\n\t\t\tthis.matrixWorldNeedsUpdate = false;\n\n\t\t}\n\n\t\t// Update child matrices\n\t\tif ( updateChildren ) {\n\n\t\t\tthis.traverse( c => {\n\n\t\t\t\tif ( this !== c ) {\n\n\t\t\t\t\tc.updateMatrixWorld( false );\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t}\n\n\t}\n\n}\n","import { vec3 } from 'gl-matrix';\nimport { PI, PI2, HALF_PI } from './constants.js';\n\n// Clamp the given angle to ( - PI, PI ]\nfunction clampEulerValue( value ) {\n\n\tlet result = value % PI2;\n\tif ( result > PI ) {\n\n\t\tresult -= PI2;\n\n\t} else if ( result <= - PI ) {\n\n\t\tresult += PI2;\n\n\t}\n\n\treturn result;\n\n}\n\n// Convert `toAdjust` to be the equivalent rotation that is closest to target.\nfunction toSmallestEulerValueDistance( target, toAdjust ) {\n\n\tconst wholeRotation = Math.round( target / PI2 ) * PI2;\n\tconst clampedValue = clampEulerValue( toAdjust );\n\n\tlet result = wholeRotation + clampedValue;\n\tconst delta = result - target;\n\tif ( Math.abs( delta ) > PI ) {\n\n\t\tresult -= Math.sign( delta ) * PI2;\n\n\t}\n\n\treturn result;\n\n}\n\n// Convert the set of euler angles toAdjust to the smallest equivalent rotation\n// that is closest to target.\nfunction toSmallestEulerDistance( output, target, toAdjust ) {\n\n\toutput[ 0 ] = toSmallestEulerValueDistance( target[ 0 ], toAdjust[ 0 ] );\n\toutput[ 1 ] = toSmallestEulerValueDistance( target[ 1 ], toAdjust[ 1 ] );\n\toutput[ 2 ] = toSmallestEulerValueDistance( target[ 2 ], toAdjust[ 2 ] );\n\n}\n\n// Return the total diff between euler values\nfunction diffEulerDistance( a, b ) {\n\n\t// if `a` or `b` is a redundant twist representation then we convert them to the\n\t// closest twist variation\n\n\tlet result =\n\t\tMath.abs( a[ 0 ] - b[ 0 ] ) +\n\t\tMath.abs( a[ 1 ] - b[ 1 ] ) +\n\t\tMath.abs( a[ 2 ] - b[ 2 ] );\n\n\treturn result;\n\n}\n\n// Convert the given euler angles to an equivalent rotation\nfunction getRedundantEulerRepresentation( output, input ) {\n\n\toutput[ 0 ] = input[ 0 ] + PI;\n\toutput[ 1 ] = PI - input[ 1 ];\n\toutput[ 2 ] = input[ 2 ] + PI;\n\n}\n\nfunction isRedundantTwist( euler ) {\n\n\tconst pivotAngle = clampEulerValue( euler[ 1 ] );\n\tif ( Math.abs( Math.abs( pivotAngle ) - HALF_PI ) > 1e-7 ) {\n\n\t\treturn false;\n\n\t}\n\n\treturn true;\n\n}\n\n// If toAdjust has a redundant rotation axis then find the representation that's closest to\n// the target set of angles.\nfunction toSmallestRedundantTwistRepresentation( output, target, toAdjust ) {\n\n\tif ( ! isRedundantTwist( toAdjust ) ) {\n\n\t\treturn false;\n\n\t}\n\n\tconst pivotAngle = clampEulerValue( toAdjust[ 1 ] );\n\n\t// we have a redundant axis\n\tconst zRotationSign = - 1 * Math.sign( pivotAngle );\n\tconst combinedXRotation = toAdjust[ 0 ] + zRotationSign * toAdjust[ 2 ];\n\n\toutput[ 0 ] = target[ 0 ];\n\toutput[ 1 ] = toSmallestEulerValueDistance( target[ 1 ], toAdjust[ 1 ] );\n\toutput[ 2 ] = toSmallestEulerValueDistance( target[ 2 ], zRotationSign * ( combinedXRotation - target[ 0 ] ) );\n\n\ttoSmallestEulerDistance( output, target, output );\n\n\treturn true;\n\n}\n\n// Returns the closest euler representation\nconst tempEuler1 = new Float64Array( 3 );\nconst tempEuler2 = new Float64Array( 3 );\nfunction getClosestEulerRepresentation( output, target, input ) {\n\n\tlet score = Infinity;\n\tif ( isRedundantTwist( input ) ) {\n\n\t\ttoSmallestRedundantTwistRepresentation( tempEuler1, target, input );\n\n\t\t// TODO: is checking the redundant direction necessary here?\n\t\tgetRedundantEulerRepresentation( tempEuler2, input );\n\t\ttoSmallestRedundantTwistRepresentation( tempEuler2, target, tempEuler2 );\n\n\t\tconst d1 = diffEulerDistance( target, tempEuler1 );\n\t\tconst d2 = diffEulerDistance( target, tempEuler2 );\n\t\tif ( d1 < d2 ) {\n\n\t\t\tvec3.copy( output, tempEuler1 );\n\t\t\tscore = d1;\n\n\t\t} else {\n\n\t\t\tvec3.copy( output, tempEuler2 );\n\t\t\tscore = d2;\n\n\t\t}\n\n\t}\n\n\t// There seems to be a chance that these representations are \"closer\" than the twist ones\n\t// in the twist case. Possibly due to numerical precision?\n\ttoSmallestEulerDistance( tempEuler1, target, input );\n\n\tgetRedundantEulerRepresentation( tempEuler2, input );\n\ttoSmallestEulerDistance( tempEuler2, target, tempEuler2 );\n\n\tconst d1 = diffEulerDistance( target, tempEuler1 );\n\tconst d2 = diffEulerDistance( target, tempEuler2 );\n\tif ( d1 < score || d2 < score ) {\n\n\t\tif ( d1 < d2 ) {\n\n\t\t\tvec3.copy( output, tempEuler1 );\n\n\t\t} else {\n\n\t\t\tvec3.copy( output, tempEuler2 );\n\n\t\t}\n\n\t}\n\n\n}\n\nexport {\n\tclampEulerValue,\n\ttoSmallestEulerValueDistance,\n\ttoSmallestEulerDistance,\n\tdiffEulerDistance,\n\tgetRedundantEulerRepresentation,\n\ttoSmallestRedundantTwistRepresentation,\n\tgetClosestEulerRepresentation,\n\tisRedundantTwist,\n};\n\n","// https://github.com/toji/gl-matrix/issues/329\nimport { mat4, vec3 } from 'gl-matrix';\nimport { RAD2DEG } from './constants.js';\nimport { smallestDifferenceQuaternion } from './quaternion.js';\n\nconst tempPos = new Float64Array( 3 );\nconst tempQuat = new Float64Array( 4 );\nconst tempPos2 = new Float64Array( 3 );\nconst tempQuat2 = new Float64Array( 4 );\n\n/**\n * Returns an euler angle representation of a quaternion\n * @param {vec3} out Euler angles, pitch-yaw-roll\n * @param {quat} mat Quaternion\n * @return {vec3} out\n */\nexport function getEuler( out, quat ) {\n\n\t// https://math.stackexchange.com/questions/2975109/how-to-convert-euler-angles-to-quaternions-and-get-the-same-euler-angles-back-fr\n\tconst [ x, y, z, w ] = quat;\n\n\tconst t0 = 2.0 * ( w * x + y * z );\n\tconst t1 = 1.0 - 2.0 * ( x * x + y * y );\n\tconst roll = Math.atan2( t0, t1 );\n\n\tlet t2 = 2.0 * ( w * y - z * x );\n\tt2 = t2 > 1.0 ? 1.0 : t2;\n\tt2 = t2 < - 1.0 ? - 1.0 : t2;\n\tconst pitch = Math.asin( t2 );\n\n\tconst t3 = 2.0 * ( w * z + x * y );\n\tconst t4 = 1.0 - 2.0 * ( y * y + z * z );\n\tconst yaw = Math.atan2( t3, t4 );\n\n\tout[ 0 ] = roll * RAD2DEG;\n\tout[ 1 ] = pitch * RAD2DEG;\n\tout[ 2 ] = yaw * RAD2DEG;\n\n\treturn out;\n\n}\n\nexport function getMatrixDifference( a, b, outPos, outQuat ) {\n\n\tmat4.getTranslation( tempPos, a );\n\tmat4.getRotation( tempQuat, a );\n\n\tmat4.getTranslation( tempPos2, b );\n\tmat4.getRotation( tempQuat2, b );\n\n\tvec3.subtract( outPos, tempPos, tempPos2 );\n\tsmallestDifferenceQuaternion( outQuat, tempQuat, tempQuat2 );\n\n\t// error of A - B\n\n}\n","import { mat4, quat } from 'gl-matrix';\nimport { Frame } from './Frame.js';\nimport { getClosestEulerRepresentation, toSmallestEulerValueDistance } from './utils/euler.js';\nimport { getEuler, getMatrixDifference } from './utils/glmatrix.js';\nimport { RAD2DEG, DEG2RAD } from './utils/constants.js';\n\n// degrees of freedom axes\nexport const DOF = {\n\tX: 0,\n\tY: 1,\n\tZ: 2,\n\tEX: 3,\n\tEY: 4,\n\tEZ: 5,\n};\n\nexport const DOF_NAMES = Object.entries( DOF ).sort( ( a, b ) => a[ 1 ] - b[ 1 ] ).map( e => e[ 0 ] );\n\nconst tempInverse = new Float32Array( 16 );\nconst tempMatrix = new Float32Array( 16 );\nconst tempQuat = new Float32Array( 4 );\nconst tempEuler = new Float32Array( 3 );\nconst tempValueEuler = new Float32Array( 3 );\nconst quatEuler = new Float32Array( 3 );\nconst tempDoFValues = new Float32Array( 6 );\n\n// generate a matrix from a set of degrees of freedom\nfunction dofToMatrix( out, dof ) {\n\n\tquat.fromEuler( tempQuat, dof[ DOF.EX ] * RAD2DEG, dof[ DOF.EY ] * RAD2DEG, dof[ DOF.EZ ] * RAD2DEG );\n\tmat4.fromRotationTranslation( out, tempQuat, dof );\n\n}\n\nexport class Joint extends Frame {\n\n\tconstructor() {\n\n\t\tsuper();\n\t\tthis.isJoint = true;\n\n\t\tthis.child = null;\n\t\tthis.isClosure = false;\n\n\t\tthis.trackJointWrap = false;\n\t\tthis.rotationDoFCount = 0;\n\t\tthis.translationDoFCount = 0;\n\n\t\t// TODO: should we make DoF Flags a bit mask flag?\n\t\tthis.dof = [];\n\t\tthis.dofFlags = new Uint8Array( 6 );\n\t\tthis.dofValues = new Float32Array( 6 );\n\t\tthis.dofTarget = new Float32Array( 6 );\n\t\tthis.dofRestPose = new Float32Array( 6 );\n\n\t\tthis.minDoFLimit = new Float32Array( 6 ).fill( - Infinity );\n\t\tthis.maxDoFLimit = new Float32Array( 6 ).fill( Infinity );\n\n\t\tthis.targetSet = false;\n\t\tthis.restPoseSet = false;\n\n\t\tthis.matrixDoFNeedsUpdate = false;\n\t\tthis.matrixDoF = new Float32Array( 16 );\n\t\tmat4.identity( this.matrixDoF );\n\n\t\tthis.cachedIdentityDoFMatrixWorld = new Float32Array( 16 );\n\t\tmat4.identity( this.cachedIdentityDoFMatrixWorld );\n\n\t\t// TODO: Consider affording control over rotation order\n\t\t// TODO: Create pre built joint types\n\n\t}\n\n\t// private helpers\n\t_getQuaternion( target, outQuat ) {\n\n\t\tquat.fromEuler( outQuat, target[ DOF.EX ], target[ DOF.EY ], target[ DOF.EZ ] );\n\n\t}\n\n\t_getEuler( target, outEuler ) {\n\n\t\toutEuler[ 0 ] = target[ DOF.EX ];\n\t\toutEuler[ 1 ] = target[ DOF.EY ];\n\t\toutEuler[ 2 ] = target[ DOF.EZ ];\n\n\t}\n\n\t_getPosition( target, outPos ) {\n\n\t\toutPos[ 0 ] = target[ DOF.X ];\n\t\toutPos[ 1 ] = target[ DOF.Y ];\n\t\toutPos[ 2 ] = target[ DOF.Z ];\n\n\t}\n\n\t_setValue( target, dof, value ) {\n\n\t\tif ( target === this.minDoFLimit || target == this.maxDoFLimit ) {\n\n\t\t\tthrow new Error( 'Joint: Cannot set minDoFLimit or maxDoFLimit with _setValue.' );\n\n\t\t}\n\n\t\tif ( dof < 0 || dof > 6 || typeof dof !== 'number' ) {\n\n\t\t\tthrow new Error( 'Joint: Invalid DoF.' );\n\n\t\t}\n\n\t\tif ( ! this.dofFlags[ dof ] ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\tconst minVal = this.minDoFLimit[ dof ];\n\t\tconst maxVal = this.maxDoFLimit[ dof ];\n\n\t\tif ( value < minVal ) {\n\n\t\t\tvalue = minVal;\n\n\t\t}\n\n\t\tif ( value > maxVal ) {\n\n\t\t\tvalue = maxVal;\n\n\t\t}\n\n\t\ttarget[ dof ] = value;\n\t\treturn value === maxVal || value === minVal;\n\n\t}\n\n\t_setValues( target, values ) {\n\n\t\tconst dof = this.dof;\n\t\tfor ( let i = 0, l = values.length; i < l; i ++ ) {\n\n\t\t\tthis._setValue( target, dof[ i ], values[ i ] );\n\n\t\t}\n\n\t}\n\n\t// TODO: these functions are unused\n\t_setViaFullPosition( target, values ) {\n\n\t\tconst dofFlags = this.dofFlags;\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\ttarget[ i ] = dofFlags[ i ] * values[ i ];\n\n\t\t}\n\n\t}\n\n\t_setViaFullEuler( target, values ) {\n\n\t\tconst dofFlags = this.dofFlags;\n\t\tfor ( let i = 3; i < 6; i ++ ) {\n\n\t\t\ttarget[ i ] = dofFlags[ i ] * values[ i - 3 ];\n\n\t\t}\n\n\t\tthis.tryMinimizeEulerAngles();\n\n\t}\n\n\t_setViaQuaternion( target, values ) {\n\n\t\tgetEuler( quatEuler, values );\n\t\tquatEuler[ 0 ] *= DEG2RAD;\n\t\tquatEuler[ 1 ] *= DEG2RAD;\n\t\tquatEuler[ 2 ] *= DEG2RAD;\n\n\t\tif ( this.trackJointWrap ) {\n\n\t\t\t// if we're tracking joint wrap then set this to be as close as possible to\n\t\t\t// the current dof settings.\n\t\t\t// TODO: How should restPose work here? Should it always be the shortest distance?\n\t\t\tconst dofValues = this.dofValues;\n\t\t\ttempEuler[ 0 ] = dofValues[ DOF.EX ];\n\t\t\ttempEuler[ 1 ] = dofValues[ DOF.EY ];\n\t\t\ttempEuler[ 2 ] = dofValues[ DOF.EZ ];\n\t\t\tgetClosestEulerRepresentation( quatEuler, tempEuler, quatEuler );\n\n\t\t}\n\n\t\tthis._setViaFullEuler( target, quatEuler );\n\n\t}\n\n\t// Set the degrees of freedom\n\tclearDoF() {\n\n\t\tthis.setDoF();\n\n\t}\n\n\tsetDoF( ...args ) {\n\n\t\targs.forEach( ( dof, i ) => {\n\n\t\t\tif ( dof < 0 || dof >= 6 ) {\n\n\t\t\t\tthrow new Error( 'Joint: Invalid degree of freedom enum ' + dof + '.' );\n\n\t\t\t}\n\n\t\t\tif ( args.includes( dof, i + 1 ) ) {\n\n\t\t\t\tthrow new Error( 'Joint: Duplicate degree of freedom ' + DOF_NAMES[ dof ] + 'specified.' );\n\n\t\t\t}\n\n\t\t\tif ( i !== 0 && args[ i - 1 ] > dof ) {\n\n\t\t\t\tthrow new Error( 'Joint: Joints degrees of freedom must be specified in position then rotation, XYZ order' );\n\n\t\t\t}\n\n\t\t} );\n\n\t\tthis.dof = args;\n\t\tthis.dofValues.fill( 0 );\n\t\tthis.dofTarget.fill( 0 );\n\t\tthis.dofRestPose.fill( 0 );\n\n\t\tthis.minDoFLimit.fill( - Infinity );\n\t\tthis.maxDoFLimit.fill( Infinity );\n\t\tthis.setMatrixDoFNeedsUpdate();\n\n\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\tthis.dofFlags[ i ] = Number( args.includes( i ) );\n\n\t\t}\n\n\t\tthis.rotationDoFCount =\n\t\t\tthis.dofFlags[ DOF.EX ] +\n\t\t\tthis.dofFlags[ DOF.EY ] +\n\t\t\tthis.dofFlags[ DOF.EZ ];\n\t\tthis.translationDoFCount =\n\t\t\tthis.dofFlags[ DOF.X ] +\n\t\t\tthis.dofFlags[ DOF.Y ] +\n\t\t\tthis.dofFlags[ DOF.Z ];\n\n\t}\n\n\t// Get and set the values of the different degrees of freedom\n\tsetDoFValues( ...values ) {\n\n\t\tthis.setMatrixDoFNeedsUpdate();\n\t\tthis._setValues( this.dofValues, values );\n\n\t}\n\n\tsetDoFValue( dof, value ) {\n\n\t\tthis.setMatrixDoFNeedsUpdate();\n\t\treturn this._setValue( this.dofValues, dof, value );\n\n\t}\n\n\tgetDoFValue( dof ) {\n\n\t\treturn this.dofValues[ dof ];\n\n\t}\n\n\tgetDoFQuaternion( outQuat ) {\n\n\t\tthis._getQuaternion( this.dofValues, outQuat );\n\n\t}\n\n\tgetDoFEuler( outEuler ) {\n\n\t\tthis._getEuler( this.dofValues, outEuler );\n\n\t}\n\n\tgetDoFPosition( outPos ) {\n\n\t\tthis._getPosition( this.dofValues, outPos );\n\n\t}\n\n\t// Get and set the restPose values of the different degrees of freedom\n\tsetRestPoseValues( ...values ) {\n\n\t\tthis._setValues( this.dofRestPose, values );\n\n\t}\n\n\tsetRestPoseValue( dof, value ) {\n\n\t\treturn this._setValue( this.dofRestPose, dof, value );\n\n\t}\n\n\tgetRestPoseValue( dof ) {\n\n\t\treturn this.dofRestPose[ dof ];\n\n\t}\n\n\tgetRestPoseQuaternion( outQuat ) {\n\n\t\tthis._getQuaternion( this.dofRestPose, outQuat );\n\n\t}\n\n\tgetRestPoseEuler( outEuler ) {\n\n\t\tthis._getEuler( this.dofRestPose, outEuler );\n\n\t}\n\n\tgetRestPosePosition( outPos ) {\n\n\t\tthis._getPosition( this.dofRestPose, outPos );\n\n\t}\n\n\t// Get and set the restPose values of the different degrees of freedom\n\tsetTargetValues( ...values ) {\n\n\t\tthis._setValues( this.dofTarget, values );\n\n\t}\n\n\tsetTargetValue( dof, value ) {\n\n\t\tthis._setValue( this.dofTarget, dof, value );\n\n\t}\n\n\tgetTargetValue( dof ) {\n\n\t\treturn this.dofTarget[ dof ];\n\n\t}\n\n\tgetTargetQuaternion( outQuat ) {\n\n\t\tthis._getQuaternion( this.dofTarget, outQuat );\n\n\t}\n\n\tgetTargetEuler( outEuler ) {\n\n\t\tthis._getEuler( this.dofTarget, outEuler );\n\n\t}\n\n\tgetTargetPosition( outPos ) {\n\n\t\tthis._getPosition( this.dofTarget, outPos );\n\n\t}\n\n\t// Joint Limits\n\tsetMinLimits( ...values ) {\n\n\t\tconst { dof } = this;\n\t\tfor ( const i in values ) {\n\n\t\t\tconst d = dof[ i ];\n\t\t\tthis.setMinLimit( d, values[ i ] );\n\n\t\t}\n\n\t}\n\n\tsetMinLimit( dof, value ) {\n\n\t\tthis.minDoFLimit[ dof ] = value;\n\t\tthis.setDoFValue( dof, this.dofValues[ dof ] );\n\n\t}\n\n\tgetMinLimit( dof ) {\n\n\t\treturn this.minDoFLimit[ dof ];\n\n\t}\n\n\tsetMaxLimits( ...values ) {\n\n\t\tconst { dof } = this;\n\t\tfor ( const i in values ) {\n\n\t\t\tconst d = dof[ i ];\n\t\t\tthis.setMaxLimit( d, values[ i ] );\n\n\t\t}\n\n\t}\n\n\tsetMaxLimit( dof, value ) {\n\n\t\tthis.maxDoFLimit[ dof ] = value;\n\t\tthis.setDoFValue( dof, this.dofValues[ dof ] );\n\n\t}\n\n\tgetMaxLimit( dof ) {\n\n\t\treturn this.maxDoFLimit[ dof ];\n\n\t}\n\n\t// Returns the error between this joint and the next link if this is a closure.\n\t// TODO: remove this and put it in solver\n\tgetClosureError( outPos, outQuat ) {\n\n\t\tif ( ! this.isClosure ) {\n\n\t\t\tthrow new Error( 'Joint: Cannot get closure error on non closure Joint.' );\n\n\t\t}\n\n\t\tthis.updateMatrixWorld();\n\t\tthis.child.updateMatrixWorld();\n\n\t\t// error from this position to child\n\t\tgetMatrixDifference( this.matrixWorld, this.child.matrixWorld, outPos, outQuat );\n\n\t}\n\n\t// Update matrix overrides\n\t// TODO: it might be best if we skip this and try to characterize joint error with quats in\n\t// the error vector\n\ttryMinimizeEulerAngles() {\n\n\t\tconst {\n\t\t\ttrackJointWrap,\n\t\t\trotationDoFCount,\n\t\t\tdofRestPose,\n\t\t\tdofTarget,\n\t\t\tdofValues,\n\t\t} = this;\n\n\t\tif ( ! trackJointWrap ) {\n\n\t\t\tif ( rotationDoFCount < 3 ) {\n\n\t\t\t\tfor ( let i = DOF.EX; i <= DOF.EZ; i ++ ) {\n\n\t\t\t\t\tdofTarget[ i ] = toSmallestEulerValueDistance( dofValues[ i ], dofTarget[ i ] );\n\t\t\t\t\tdofRestPose[ i ] = toSmallestEulerValueDistance( dofValues[ i ], dofRestPose[ i ] );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\ttempValueEuler[ 0 ] = dofValues[ DOF.EX ];\n\t\t\t\ttempValueEuler[ 1 ] = dofValues[ DOF.EY ];\n\t\t\t\ttempValueEuler[ 2 ] = dofValues[ DOF.EZ ];\n\n\t\t\t\t// update target\n\t\t\t\ttempEuler[ 0 ] = dofTarget[ DOF.EX ];\n\t\t\t\ttempEuler[ 1 ] = dofTarget[ DOF.EY ];\n\t\t\t\ttempEuler[ 2 ] = dofTarget[ DOF.EZ ];\n\n\t\t\t\tgetClosestEulerRepresentation( tempEuler, tempValueEuler, tempEuler );\n\n\t\t\t\tdofTarget[ DOF.EX ] = tempEuler[ 0 ];\n\t\t\t\tdofTarget[ DOF.EY ] = tempEuler[ 1 ];\n\t\t\t\tdofTarget[ DOF.EZ ] = tempEuler[ 2 ];\n\n\t\t\t\t// update restPose\n\t\t\t\ttempEuler[ 0 ] = dofRestPose[ DOF.EX ];\n\t\t\t\ttempEuler[ 1 ] = dofRestPose[ DOF.EY ];\n\t\t\t\ttempEuler[ 2 ] = dofRestPose[ DOF.EZ ];\n\n\t\t\t\tgetClosestEulerRepresentation( tempEuler, tempValueEuler, tempEuler );\n\n\t\t\t\tdofRestPose[ DOF.EX ] = tempEuler[ 0 ];\n\t\t\t\tdofRestPose[ DOF.EY ] = tempEuler[ 1 ];\n\t\t\t\tdofRestPose[ DOF.EZ ] = tempEuler[ 2 ];\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tgetDeltaWorldMatrix( dof, delta, outMatrix ) {\n\n\t\tconst {\n\t\t\tdofValues,\n\t\t\tminDoFLimit,\n\t\t\tmaxDoFLimit,\n\t\t\tcachedIdentityDoFMatrixWorld,\n\t\t} = this;\n\n\t\tthis.updateMatrixWorld();\n\n\t\t// copy out set of dof values\n\t\ttempDoFValues.set( dofValues );\n\n\t\t// get the state\n\t\tconst min = minDoFLimit[ dof ];\n\t\tconst max = maxDoFLimit[ dof ];\n\t\tconst currVal = tempDoFValues[ dof ];\n\n\t\t// check what our slack is\n\t\tconst minSlack = currVal - min;\n\t\tconst maxSlack = max - currVal;\n\n\t\t// If we're constrained by either limit then move in the other direction then\n\t\t// use the direction with the most slack.\n\t\tlet newVal = currVal + delta;\n\t\tconst isMaxConstrained = delta > 0 && newVal > max;\n\t\tconst isMinConstrained = delta < 0 && newVal < min;\n\t\tconst doInvert = ( isMaxConstrained && minSlack > maxSlack ) || ( isMinConstrained && maxSlack > minSlack );\n\t\tif ( doInvert ) {\n\n\t\t\tnewVal = currVal - delta;\n\n\t\t}\n\n\t\t// update our dof array and compute the matrix\n\t\ttempDoFValues[ dof ] = newVal;\n\n\t\tdofToMatrix( tempMatrix, tempDoFValues );\n\n\t\tmat4.multiply( outMatrix, cachedIdentityDoFMatrixWorld, tempMatrix );\n\n\t\treturn doInvert;\n\n\t}\n\n\t// matrix updates\n\tsetMatrixDoFNeedsUpdate() {\n\n\t\tif ( this.matrixDoFNeedsUpdate === false ) {\n\n\t\t\tthis.matrixDoFNeedsUpdate = true;\n\t\t\tthis.setMatrixWorldNeedsUpdate();\n\n\t\t}\n\n\t}\n\n\tupdateDoFMatrix() {\n\n\t\tif ( this.matrixDoFNeedsUpdate ) {\n\n\t\t\tdofToMatrix( this.matrixDoF, this.dofValues );\n\t\t\tthis.matrixDoFNeedsUpdate = false;\n\n\n\t\t}\n\n\t}\n\n\tcomputeMatrixWorld() {\n\n\t\tconst {\n\t\t\tparent,\n\t\t\tmatrixWorld,\n\t\t\tmatrix,\n\t\t\tmatrixDoF,\n\t\t\tcachedIdentityDoFMatrixWorld\n\t\t} = this;\n\n\t\tthis.updateDoFMatrix();\n\n\t\tmat4.multiply( matrixWorld, matrix, matrixDoF );\n\t\tif ( parent ) {\n\n\t\t\tmat4.multiply( matrixWorld, parent.matrixWorld, matrixWorld );\n\t\t\tmat4.multiply( cachedIdentityDoFMatrixWorld, parent.matrixWorld, matrix );\n\n\t\t} else {\n\n\t\t\tmat4.copy( cachedIdentityDoFMatrixWorld, matrix );\n\n\t\t}\n\n\n\n\t}\n\n\t// Add child overrides\n\tmakeClosure( child ) {\n\n\t\tif ( ! child.isLink || this.child || child.parent === this ) {\n\n\t\t\tthrow new Error( 'Joint: Given child cannot be used to make closure.' );\n\n\t\t} else {\n\n\t\t\t// don't store the closure child in the children array to avoid\n\t\t\t// implicit traversal.\n\t\t\tthis.child = child;\n\t\t\tthis.isClosure = true;\n\t\t\tchild.closureJoints.push( this );\n\n\t\t}\n\n\t}\n\n\taddChild( child ) {\n\n\t\tif ( ! child.isLink || this.child || child.parent === this ) {\n\n\t\t\tthrow new Error( 'Joint: Given child cannot be added to Joint.' );\n\n\t\t} else {\n\n\t\t\tsuper.addChild( child );\n\t\t\tthis.child = child;\n\t\t\tthis.isClosure = false;\n\n\t\t}\n\n\t}\n\n\tremoveChild( child ) {\n\n\t\tif ( this.isClosure ) {\n\n\t\t\tif ( this.child !== child ) {\n\n\t\t\t\tthrow new Error( 'Frame: Child to be removed is not a child of this Joint.' );\n\n\t\t\t} else {\n\n\t\t\t\tthis.child = null;\n\t\t\t\tthis.isClosure = false;\n\n\t\t\t\tconst index = child.closureJoints.indexOf( this );\n\t\t\t\tchild.closureJoints.splice( index, 1 );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tsuper.removeChild( child );\n\n\t\t}\n\n\t}\n\n\tattachChild( child ) {\n\n\t\tsuper.attachChild( child );\n\n\t\t// remove the dof rotation afterward\n\t\tmat4.invert( tempInverse, this.matrixDoF );\n\t\tmat4.multiply( child.matrix, tempInverse, child.matrix );\n\t\tmat4.getTranslation( child.position, child.matrix );\n\t\tmat4.getRotation( child.quaternion, child.matrix );\n\n\t}\n\n\tdetachChild( child ) {\n\n\t\tsuper.detachChild( child );\n\n\t\t// remove the dof rotation afterward\n\t\tmat4.invert( tempInverse, this.matrixDoF );\n\t\tmat4.multiply( child.matrix, tempInverse, child.matrix );\n\t\tmat4.getTranslation( child.position, child.matrix );\n\t\tmat4.getRotation( child.quaternion, child.matrix );\n\n\t}\n\n}\n","import { vec3, vec4 } from 'gl-matrix';\nimport { DOF } from '../Joint.js';\n\nconst tempPos = new Float64Array( 3 );\nconst tempQuat = new Float64Array( 4 );\nconst tempEuler = new Float64Array( 3 );\nexport function accumulateClosureError(\n\tsolver,\n\tjoint,\n\tstartIndex,\n\terrorVector = null,\n\tresult = { isConverged: false, rowCount: 7, totalError: 0 }\n) {\n\n\tconst {\n\t\ttranslationConvergeThreshold,\n\t\trotationConvergeThreshold,\n\t\ttranslationErrorClamp,\n\t\trotationErrorClamp,\n\t\ttranslationFactor,\n\t\trotationFactor,\n\t} = solver;\n\n\tconst {\n\t\ttranslationDoFCount,\n\t\trotationDoFCount,\n\t\tdofFlags,\n\t\tdof,\n\t} = joint;\n\n\t// Get the error from child towards the closure target\n\tjoint.getClosureError( tempPos, tempQuat );\n\n\tlet rowCount = 7;\n\tif ( joint.isGoal ) {\n\n\t\ttempPos[ 0 ] *= dofFlags[ 0 ];\n\t\ttempPos[ 1 ] *= dofFlags[ 1 ];\n\t\ttempPos[ 2 ] *= dofFlags[ 2 ];\n\t\trowCount = translationDoFCount;\n\n\t\tif ( rotationDoFCount === 0 ) {\n\n\t\t\ttempQuat[ 0 ] = 0;\n\t\t\ttempQuat[ 1 ] = 0;\n\t\t\ttempQuat[ 2 ] = 0;\n\t\t\ttempQuat[ 3 ] = 0;\n\n\t\t} else {\n\n\t\t\trowCount += 4;\n\n\t\t}\n\n\t}\n\n\tlet isConverged = false;\n\tlet totalError = 0;\n\tconst posMag = vec3.length( tempPos );\n\tconst rotMag = vec4.length( tempQuat );\n\tif (\n\t\tposMag < translationConvergeThreshold &&\n\t\trotMag < rotationConvergeThreshold\n\t) {\n\n\t\tisConverged = true;\n\n\t}\n\n\ttotalError += posMag + rotMag;\n\n\tif ( errorVector ) {\n\n\t\tif ( posMag > translationErrorClamp ) {\n\n\t\t\tvec3.scale( tempPos, tempPos, translationErrorClamp / posMag );\n\n\t\t}\n\n\t\tvec4.scale( tempPos, tempPos, translationFactor );\n\n\t\tif ( rotMag > rotationErrorClamp ) {\n\n\t\t\tvec4.scale( tempQuat, tempQuat, rotationErrorClamp / rotMag );\n\n\t\t}\n\n\t\tvec4.scale( tempQuat, tempQuat, rotationFactor );\n\n\t\tif ( joint.isGoal ) {\n\n\t\t\tfor ( let i = 0; i < translationDoFCount; i ++ ) {\n\n\t\t\t\tconst d = dof[ i ];\n\t\t\t\terrorVector[ startIndex + i ][ 0 ] = tempPos[ d ];\n\n\t\t\t}\n\n\t\t\tif ( joint.rotationDoFCount === 3 ) {\n\n\t\t\t\terrorVector[ startIndex + translationDoFCount + 0 ][ 0 ] = tempQuat[ 0 ];\n\t\t\t\terrorVector[ startIndex + translationDoFCount + 1 ][ 0 ] = tempQuat[ 1 ];\n\t\t\t\terrorVector[ startIndex + translationDoFCount + 2 ][ 0 ] = tempQuat[ 2 ];\n\t\t\t\terrorVector[ startIndex + translationDoFCount + 3 ][ 0 ] = tempQuat[ 3 ];\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\terrorVector[ startIndex + 0 ][ 0 ] = tempPos[ 0 ];\n\t\t\terrorVector[ startIndex + 1 ][ 0 ] = tempPos[ 1 ];\n\t\t\terrorVector[ startIndex + 2 ][ 0 ] = tempPos[ 2 ];\n\n\t\t\terrorVector[ startIndex + 3 ][ 0 ] = tempQuat[ 0 ];\n\t\t\terrorVector[ startIndex + 4 ][ 0 ] = tempQuat[ 1 ];\n\t\t\terrorVector[ startIndex + 5 ][ 0 ] = tempQuat[ 2 ];\n\t\t\terrorVector[ startIndex + 6 ][ 0 ] = tempQuat[ 3 ];\n\n\t\t}\n\n\t}\n\n\tresult.totalError = totalError;\n\tresult.isConverged = isConverged;\n\tresult.rowCount = rowCount;\n\treturn result;\n\n}\n\nexport function accumulateTargetError(\n\tsolver,\n\tjoint,\n\tstartIndex,\n\terrorVector = null,\n\tresult = { isConverged: false, rowCount: 7, totalError: 0 }\n) {\n\n\t// Find whether or not the target has converged or not\n\tconst {\n\t\ttranslationConvergeThreshold,\n\t\trotationConvergeThreshold,\n\t\tlockedJointDoFCount,\n\t\ttranslationErrorClamp,\n\t\trotationErrorClamp,\n\t\tlockedJointDoF,\n\t} = solver;\n\n\tconst {\n\t\tdofTarget,\n\t\tdofValues,\n\t\ttranslationDoFCount,\n\t\trotationDoFCount,\n\t\ttranslationFactor,\n\t\trotationFactor,\n\t\tdofList,\n\t} = joint;\n\n\t// get the position delta\n\tconst posDelta = vec3.distance( dofValues, dofTarget );\n\n\t// TODO: if three euler angles are being used we should set this to a quaternion to measure\n\t// error rather than euler angles. We should instead just always use quaternions for targets\n\t// for now.\n\t// Before running this solver we try to ensure the target and restPose are minimized\n\tlet rotDelta =\n\t\tdofTarget[ DOF.EX ] - dofValues[ DOF.EX ] +\n\t\tdofTarget[ DOF.EY ] - dofValues[ DOF.EY ] +\n\t\tdofTarget[ DOF.EZ ] - dofValues[ DOF.EZ ];\n\n\t// Get the row count\n\tconst lockedDoFCount = lockedJointDoFCount.get( joint ) || 0;\n\tresult.rowCount = translationDoFCount + rotationDoFCount - lockedDoFCount;\n\tresult.isConverged = posDelta < translationConvergeThreshold && rotDelta < rotationConvergeThreshold;\n\tresult.totalError = posDelta + rotDelta;\n\n\tif ( errorVector ) {\n\n\t\tconst lockedDoF = lockedJointDoF.get( joint );\n\t\tconst isLocked = lockedDoFCount !== 0;\n\n\t\tlet rowIndex = 0;\n\n\t\t// error from current state to target\n\t\ttempPos[ 0 ] = dofTarget[ 0 ] - dofValues[ 0 ];\n\t\ttempPos[ 1 ] = dofTarget[ 1 ] - dofValues[ 1 ];\n\t\ttempPos[ 2 ] = dofTarget[ 2 ] - dofValues[ 2 ];\n\n\t\t// clamp the position delta to the max error step\n\t\tconst posMag = vec3.length( tempPos );\n\t\tvec3.scale( tempPos, tempPos, translationFactor * translationErrorClamp / posMag );\n\t\tfor ( let i = 0, l = translationDoFCount; i < l; i ++ ) {\n\n\t\t\tconst dof = dofList[ i ];\n\n\t\t\t// skip this degree of freedom if it's locked\n\t\t\tif ( isLocked && lockedDoF[ dof ] ) {\n\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\terrorVector[ startIndex + rowIndex ][ 0 ] = tempPos[ dof ];\n\t\t\trowIndex ++;\n\n\t\t}\n\n\t\t// get the euler differences\n\t\t// before running this solver we minimize the euler targets\n\t\ttempEuler[ 0 ] = joint.dofTarget[ 3 ] - joint.dofValues[ 3 ];\n\t\ttempEuler[ 1 ] = joint.dofTarget[ 4 ] - joint.dofValues[ 4 ];\n\t\ttempEuler[ 2 ] = joint.dofTarget[ 5 ] - joint.dofValues[ 5 ];\n\n\t\t// clamp the euler difference to the error step magnitude\n\t\tconst eulerMag = vec3.length( tempEuler );\n\t\tvec3.scale( tempEuler, tempEuler, rotationFactor * rotationErrorClamp / eulerMag );\n\t\tfor ( let i = translationDoFCount, l = translationDoFCount + rotationDoFCount; i < l; i ++ ) {\n\n\t\t\tconst dof = dofList[ i ];\n\n\t\t\t// skip this degree of freedom if it's locked\n\t\t\tif ( isLocked && lockedDoF[ dof ] ) {\n\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\terrorVector[ startIndex + rowIndex ][ 0 ] = tempEuler[ dof ];\n\t\t\trowIndex ++;\n\n\t\t}\n\n\t}\n\n}\n","import linearSolve from 'linear-solve';\nimport { SVD } from 'svd-js';\n\nfunction transpose( outMatrix, a ) {\n\n\tconst tr = a.length;\n\tconst tc = a[ 0 ].length;\n\n\tfor ( let r = 0; r < tr; r ++ ) {\n\n\t\tfor ( let c = 0; c < tc; c ++ ) {\n\n\t\t\toutMatrix[ c ][ r ] = a[ r ][ c ];\n\n\t\t}\n\n\t}\n\n}\n\nfunction identity( outMatrix ) {\n\n\tfor ( let r = 0, tr = outMatrix.length; r < tr; r ++ ) {\n\n\t\tfor ( let c = 0, tc = outMatrix.length; c < tc; c ++ ) {\n\n\t\t\toutMatrix[ r ][ c ] = r === c ? 1 : 0;\n\n\t\t}\n\n\t}\n\n}\n\nfunction scale( outMatrix, matrix, scalar ) {\n\n\tfor ( let r = 0, tr = outMatrix.length; r < tr; r ++ ) {\n\n\t\tfor ( let c = 0, tc = outMatrix.length; c < tc; c ++ ) {\n\n\t\t\toutMatrix[ r ][ c ] = matrix[ r ][ c ] * scalar;\n\n\t\t}\n\n\t}\n\n}\n\nfunction multiply( outMatrix, a, b ) {\n\n\tif ( a === outMatrix || b === outMatrix ) {\n\n\t\tthrow new Error( 'Matrix: Cannot multiply to a matrix in place.' );\n\n\t}\n\n\t// a is m x n\n\t// b is n x k\n\t// outMatrix is m x k\n\n\t// m = a rows\n\t// n = a cols or b rows\n\t// k = b cols\n\n\tconst m = a.length;\n\tconst n = b.length;\n\tconst k = b[ 0 ].length;\n\n\t// iterate over m\n\tfor ( let r = 0, tr = m; r < tr; r ++ ) {\n\n\t\t// iterate over k\n\t\tfor ( let c = 0, tc = k; c < tc; c ++ ) {\n\n\t\t\tlet sum = 0;\n\n\t\t\t// iterate over n\n\t\t\tfor ( let i = 0, ti = n; i < ti; i ++ ) {\n\n\t\t\t\tsum += a[ r ][ i ] * b[ i ][ c ];\n\n\t\t\t}\n\n\t\t\toutMatrix[ r ][ c ] = sum;\n\n\t\t}\n\n\t}\n\n}\n\nfunction create( row, col ) {\n\n\tconst result = new Array( row );\n\tfor ( let i = 0; i < row; i ++ ) {\n\n\t\tresult[ i ] = new Float64Array( col );\n\n\t}\n\n\treturn result;\n\n}\n\nfunction copy( outMatrix, sourceMatrix ) {\n\n\tconst tr = sourceMatrix.length;\n\tconst tc = sourceMatrix[ 0 ].length;\n\tfor ( let r = 0; r < tr; r ++ ) {\n\n\t\tfor ( let c = 0; c < tc; c ++ ) {\n\n\t\t\toutMatrix[ r ][ c ] = sourceMatrix[ r ][ c ];\n\n\t\t}\n\n\t}\n\n}\n\nfunction clone( matrix ) {\n\n\tconst rows = matrix.length;\n\tconst cols = matrix[ 0 ].length;\n\tconst resultMatrix = create( rows, cols );\n\tcopy( resultMatrix, matrix );\n\treturn resultMatrix;\n\n}\n\nfunction solve( outMatrix, matrix, vector ) {\n\n\tconst res = linearSolve.solve( matrix, vector );\n\tfor ( let i = 0, l = res.length; i < l; i ++ ) {\n\n\t\toutMatrix[ i ].set( res[ i ] );\n\n\t}\n\n}\n\nfunction svd( ru, rq, rv, matrix ) {\n\n\tconst { u, v, q } = SVD( matrix );\n\n\tconst urows = u.length;\n\tfor ( let r = 0; r < urows; r ++ ) {\n\n\t\tru[ r ].set( u[ r ] );\n\n\t}\n\n\tconst vrows = v.length;\n\tfor ( let r = 0; r < vrows; r ++ ) {\n\n\t\trv[ r ].set( v[ r ] );\n\n\t}\n\n\tconst qrows = q.length;\n\tfor ( let r = 0; r < qrows; r ++ ) {\n\n\t\tconst rqrow = rq[ r ];\n\t\tconst qval = q[ r ];\n\t\trqrow.fill( 0 );\n\t\trqrow[ r ] = qval;\n\n\t}\n\n}\n\nfunction invert( outMatrix, matrix ) {\n\n\tconst res = linearSolve.invert( matrix );\n\n\tconst tr = matrix[ 0 ].length;\n\tconst tc = matrix.length;\n\tfor ( let r = 0; r < tr; r ++ ) {\n\n\t\tfor ( let c = 0; c < tc; c ++ ) {\n\n\t\t\toutMatrix[ r ][ c ] = res[ r ][ c ];\n\n\t\t}\n\n\t}\n\n}\n\nfunction add( outMatrix, a, b ) {\n\n\tconst tr = a.length;\n\tconst tc = a[ 0 ].length;\n\tfor ( let r = 0; r < tr; r ++ ) {\n\n\t\tfor ( let c = 0; c < tc; c ++ ) {\n\n\t\t\toutMatrix[ r ][ c ] = a[ r ][ c ] + b[ r ][ c ];\n\n\t\t}\n\n\t}\n\n}\n\nfunction subtract( outMatrix, a, b ) {\n\n\tconst tr = a.length;\n\tconst tc = a[ 0 ].length;\n\tfor ( let r = 0; r < tr; r ++ ) {\n\n\t\tfor ( let c = 0; c < tc; c ++ ) {\n\n\t\t\toutMatrix[ r ][ c ] = a[ r ][ c ] - b[ r ][ c ];\n\n\t\t}\n\n\t}\n\n}\n\nfunction magnitudeSquared( matrix ) {\n\n\tlet sum = 0;\n\tconst rows = matrix.length;\n\tconst cols = matrix[ 0 ].length;\n\tfor ( let r = 0; r < rows; r ++ ) {\n\n\t\tfor ( let c = 0; c < cols; c ++ ) {\n\n\t\t\tsum += matrix[ r ][ c ] ** 2;\n\n\t\t}\n\n\t}\n\n\treturn sum;\n\n}\n\nfunction magnitude( matrix ) {\n\n\treturn Math.sqrt( magnitudeSquared( matrix ) );\n\n}\n\nfunction toString( matrix, dec = 3 ) {\n\n\tconst rows = matrix.length;\n\tconst cols = matrix[ 0 ].length;\n\tlet str = '';\n\tfor ( let r = 0; r < rows; r ++ ) {\n\n\t\tfor ( let c = 0; c < cols; c ++ ) {\n\n\t\t\tstr += matrix[ r ][ c ].toFixed( dec ) + ', ';\n\n\t\t}\n\n\t\tstr += '\\n';\n\n\t}\n\n\treturn str;\n\n}\n\nfunction log( matrix, dec ) {\n\n\tconsole.log( toString( matrix, dec ) );\n\n}\n\nexport const mat = {\n\ttranspose,\n\tidentity,\n\tscale,\n\tmultiply,\n\tcreate,\n\tcopy,\n\tclone,\n\tsolve,\n\tsvd,\n\tinvert,\n\tadd,\n\tsubtract,\n\tmagnitudeSquared,\n\tmagnitude,\n\ttoString,\n\tlog,\n};\n","import { vec3, vec4, mat4 } from 'gl-matrix';\nimport { accumulateClosureError, accumulateTargetError } from './utils/solver.js';\nimport { mat } from './utils/matrix.js';\nimport { getMatrixDifference } from './utils/glmatrix.js';\n\n// temp reusable variables\nconst targetRelativeToJointMatrix = new Float64Array( 16 );\nconst targetDeltaWorldMatrix = new Float64Array( 16 );\nconst tempDeltaWorldMatrix = new Float64Array( 16 );\nconst tempInverseMatrixWorld = new Float64Array( 16 );\nconst tempQuat = new Float64Array( 4 );\nconst tempPos = new Float64Array( 3 );\nconst tempQuat2 = new Float64Array( 4 );\nconst tempPos2 = new Float64Array( 3 );\n\nconst targetJoints = [];\nconst freeJoints = [];\nconst errorResultInfo = {\n\trowCount: 0,\n\tisConverged: false,\n\ttotalError: 0,\n};\nconst dofResultInfo = {\n\terrorRows: 0,\n\tfreeDoF: 0,\n\ttotalError: 0,\n};\n\nexport const SOLVE_STATUS = {\n\n\tCONVERGED: 0,\n\tSTALLED: 1,\n\tDIVERGED: 2,\n\tTIMEOUT: 3,\n\n};\n\nexport const SOLVE_STATUS_NAMES = Object.entries( SOLVE_STATUS ).sort( ( a, b ) => a[ 1 ] - b[ 1 ] ).map( el => el[ 0 ] );\n\nexport class ChainSolver {\n\n\tconstructor( chain ) {\n\n\t\tthis.chain = Array.from( chain );\n\n\t\t// list of targets we're trying to minimize in the chain\n\t\tthis.targets = null;\n\n\t\t// map of joint -> closures that the given joint affects\n\t\tthis.affectedClosures = null;\n\n\t\t// map of joint -> closure children that the given joint affects\n\t\tthis.affectedConnectedClosures = null;\n\n\t\t// map of joint -> that stores the amount of DoF that are locked after\n\t\t// hitting a joint limit.\n\t\t// Undefined or 0 if none are locked\n\t\tthis.lockedJointDoFCount = null;\n\n\t\t// map of joint -> list of locked DoF\n\t\tthis.lockedJointDoF = null;\n\n\t\t// map of joint -> previous joint angles for resetting joint angles on\n\t\t// divergence check.\n\t\tthis.prevDoFValues = null;\n\n\t\t// options -- these are set by the containing Solver.\n\t\tthis.maxIterations = - 1;\n\n\t\tthis.matrixPool = null;\n\n\t\tthis.useSVD = false;\n\n\t\tthis.translationConvergeThreshold = - 1;\n\t\tthis.rotationConvergeThreshold = - 1;\n\n\t\tthis.translationFactor = - 1;\n\t\tthis.rotationFactor = - 1;\n\n\t\tthis.translationStep = - 1;\n\t\tthis.rotationStep = - 1;\n\n\t\tthis.translationErrorClamp = - 1;\n\t\tthis.rotationErrorClamp = - 1;\n\n\t\tthis.stallThreshold = - 1;\n\t\tthis.dampingFactor = - 1;\n\t\tthis.divergeThreshold = - 1;\n\t\tthis.restPoseFactor = - 1;\n\n\t\tthis.init();\n\n\t}\n\n\tinit() {\n\n\t\t// Find all joints with targets.\n\t\tconst chain = this.chain;\n\t\tconst targets = chain.filter( j => j.targetSet || j.isClosure );\n\n\t\tconst lockedJointDoF = new Map();\n\t\tconst lockedJointDoFCount = new Map();\n\t\tconst prevDoFValues = new Map();\n\n\t\tconst affectedClosures = new Map();\n\t\tconst affectedConnectedClosures = new Map();\n\t\tchain.forEach( j => {\n\n\t\t\t// Track which joints will have a direct affect on which targets move\n\t\t\t// for closure end effectors.\n\t\t\taffectedClosures.set( j, new Set() );\n\t\t\taffectedConnectedClosures.set( j, new Set() );\n\n\t\t\t// Initialize our array with all possible degrees of freedom\n\t\t\tlockedJointDoF.set( j, new Uint8Array( 6 ) );\n\t\t\tprevDoFValues.set( j, new Float64Array( 6 ) );\n\n\t\t} );\n\n\t\ttargets.forEach( target => {\n\n\t\t\tif ( target.isClosure ) {\n\n\t\t\t\tlet currJoint = target;\n\n\t\t\t\t// climb the joint tree and mark every joint as affecting this closure end.\n\t\t\t\twhile ( currJoint ) {\n\n\t\t\t\t\tif ( currJoint.isJoint ) {\n\n\t\t\t\t\t\taffectedClosures.get( currJoint ).add( target );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tcurrJoint = currJoint.parent;\n\n\t\t\t\t}\n\n\t\t\t\t// and mark the joints up the other chain as effecting the other connector link.\n\t\t\t\tcurrJoint = target.child;\n\t\t\t\twhile ( currJoint ) {\n\n\t\t\t\t\tif ( currJoint.isJoint ) {\n\n\t\t\t\t\t\taffectedConnectedClosures.get( currJoint ).add( target );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tcurrJoint = currJoint.parent;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} );\n\n\t\tthis.targets = targets;\n\t\tthis.affectedClosures = affectedClosures;\n\t\tthis.affectedConnectedClosures = affectedConnectedClosures;\n\t\tthis.lockedJointDoF = lockedJointDoF;\n\t\tthis.lockedJointDoFCount = lockedJointDoFCount;\n\t\tthis.prevDoFValues = prevDoFValues;\n\n\t}\n\n\tsolve() {\n\n\t\tconst {\n\t\t\tdivergeThreshold,\n\t\t\tstallThreshold,\n\t\t\tchain,\n\t\t\trestPoseFactor,\n\t\t\tlockedJointDoFCount,\n\t\t\tprevDoFValues,\n\t\t\tuseSVD,\n\t\t\tmatrixPool,\n\t\t} = this;\n\n\t\tlet iterations = 0;\n\t\tlet prevErrorMagnitude = Infinity;\n\t\tlet status = - 1;\n\n\t\t// Clear out all the locked joints\n\t\tlockedJointDoFCount.clear();\n\n\t\t// TODO: instead of trying to use minimal euler angles we should try to represent joint\n\t\t// error as a quaternion in the quaternion vector.\n\t\tfor ( let i = 0, l = chain.length; i < l; i ++ ) {\n\n\t\t\tconst joint = chain[ i ];\n\t\t\tif ( joint.targetSet || joint.restPoseSet ) {\n\n\t\t\t\tjoint.tryMinimizeEulerAngles();\n\n\t\t\t}\n\n\t\t}\n\n\t\tdo {\n\n\t\t\tmatrixPool.releaseAll();\n\n\t\t\t// Make sure our matrices are all up to date\n\t\t\tfor ( let i = 0, l = chain.length; i < l; i ++ ) {\n\n\t\t\t\tconst joint = chain[ i ];\n\t\t\t\tjoint.updateMatrixWorld();\n\n\t\t\t}\n\n\t\t\t// TODO: this only needs to be recomputed if a joint was locked so maybe lets check that? We also\n\t\t\t// lock joints inside this function so maybe we can forgo that?\n\t\t\ttargetJoints.length = 0;\n\t\t\tfreeJoints.length = 0;\n\t\t\tthis.countUnconvergedVariables( freeJoints, targetJoints, dofResultInfo );\n\t\t\tconst { freeDoF, errorRows, totalError } = dofResultInfo;\n\n\t\t\t// Check if we've converged\n\t\t\tif ( errorRows === 0 ) {\n\n\t\t\t\tstatus = SOLVE_STATUS.CONVERGED;\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\t// Check if we've diverged\n\t\t\tif ( totalError > prevErrorMagnitude + divergeThreshold ) {\n\n\t\t\t\tprevDoFValues.forEach( ( dofValues, joint ) => {\n\n\t\t\t\t\tjoint.dofValues.set( dofValues );\n\t\t\t\t\tjoint.setMatrixDoFNeedsUpdate();\n\n\t\t\t\t} );\n\n\n\t\t\t\tstatus = SOLVE_STATUS.DIVERGED;\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tprevErrorMagnitude = totalError;\n\n\t\t\t// Check if we've hit max iterations\n\t\t\titerations ++;\n\t\t\tif ( iterations > this.maxIterations ) {\n\n\t\t\t\tstatus = SOLVE_STATUS.TIMEOUT;\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\t// A * x = b\n\t\t\t// find x such that it yields b where is the clamped error we're trying to work towards\n\t\t\t// and A is the jacobian, and x is the delta joint angles.\n\n\t\t\tconst errorVector = matrixPool.get( errorRows, 1 );\n\t\t\tthis.fillErrorVector( targetJoints, errorVector );\n\n\t\t\tconst jacobian = matrixPool.get( errorRows, freeDoF );\n\t\t\tthis.fillJacobian( targetJoints, freeJoints, jacobian );\n\n\t\t\t// Solve for the pseudo inverse of the jacobian\n\t\t\tconst pseudoInverse = matrixPool.get( freeDoF, errorRows );\n\t\t\tlet failedSVD = false;\n\t\t\tif ( useSVD ) {\n\n\t\t\t\ttry {\n\n\t\t\t\t\tconst m = errorRows;\n\t\t\t\t\tconst n = freeDoF;\n\t\t\t\t\tconst k = Math.min( m, n );\n\n\t\t\t\t\tconst u = matrixPool.get( m, k ); // m x k\n\t\t\t\t\tconst q = matrixPool.get( k, k ); // k x k\n\t\t\t\t\tconst v = matrixPool.get( n, k ); // ( k x n )^T -> ( n x k )\n\n\t\t\t\t\tmat.svd( u, q, v, jacobian );\n\n\t\t\t\t\tconst uTranspose = matrixPool.get( k, m );\n\t\t\t\t\tconst qInverse = matrixPool.get( k, k );\n\t\t\t\t\tmat.transpose( uTranspose, u );\n\n\t\t\t\t\t// if the diagonal value is close to 0 when taking the inverse\n\t\t\t\t\t// then set it to zero.\n\t\t\t\t\tfor ( let i = 0, l = q.length; i < l; i ++ ) {\n\n\t\t\t\t\t\tconst val = q[ i ][ i ];\n\t\t\t\t\t\tlet inv;\n\t\t\t\t\t\tif ( Math.abs( val ) < 0.001 ) {\n\n\t\t\t\t\t\t\tinv = 0;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tinv = 1 / val;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tqInverse[ i ][ i ] = inv;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// V * Qinv * Ut\n\t\t\t\t\tconst vqinv = matrixPool.get( n, k );\n\t\t\t\t\tmat.multiply( vqinv, v, qInverse );\n\t\t\t\t\tmat.multiply( pseudoInverse, vqinv, uTranspose );\n\n\t\t\t\t} catch ( err ) {\n\n\t\t\t\t\tfailedSVD = true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( ! useSVD || failedSVD ) {\n\n\t\t\t\t// Use a transpose pseudo inverse approach: A^T * A * x = A^T * b with the damping term\n\t\t\t\t// J^T * J * x = J^T * e\n\t\t\t\t// x = J^T * ( J * J^T )^-1 * e\n\n\t\t\t\t// and with the adding damping\n\t\t\t\t// x = J^T * ( J * J^T + l^2 * I )^-1 * e\n\n\t\t\t\t// l^2 * I\n\t\t\t\tconst jacobianIdentityDamping = matrixPool.get( errorRows, errorRows );\n\t\t\t\tmat.identity( jacobianIdentityDamping );\n\t\t\t\tmat.scale( jacobianIdentityDamping, jacobianIdentityDamping, this.dampingFactor ** 2 );\n\n\t\t\t\t// J^T\n\t\t\t\tconst jacobianTranspose = matrixPool.get( freeDoF, errorRows );\n\t\t\t\tmat.transpose( jacobianTranspose, jacobian );\n\n\t\t\t\t// J * J^T\n\t\t\t\tconst jjt = matrixPool.get( errorRows, errorRows );\n\t\t\t\tmat.multiply( jjt, jacobian, jacobianTranspose );\n\n\t\t\t\t// J * J^T + l^2 * I\n\t\t\t\tconst jjti = matrixPool.get( errorRows, errorRows );\n\t\t\t\tmat.add( jjti, jjt, jacobianIdentityDamping );\n\n\t\t\t\t// ( J * J^T + l^2 * I )^-1\n\t\t\t\tconst jjtii = matrixPool.get( errorRows, errorRows );\n\t\t\t\tmat.invert( jjtii, jjti );\n\n\t\t\t\t// J^T * ( J * J^T + l^2 * I )^-1\n\t\t\t\tmat.multiply( pseudoInverse, jacobianTranspose, jjtii );\n\n\t\t\t}\n\n\t\t\t// x = deltaTheta = J^T * ( J * J^T + l^2 * I )^-1 * e\n\t\t\tconst deltaTheta = matrixPool.get( freeDoF, 1 );\n\t\t\tmat.multiply( deltaTheta, pseudoInverse, errorVector );\n\n\t\t\tif ( restPoseFactor !== 0 ) {\n\n\t\t\t\t// Nullspace Projection\n\t\t\t\t// I - J^-1 * J is the orthogonal null space of J where J^-1 is the pseudoinverse\n\t\t\t\t// Multiplied by the rest position of each dof\n\t\t\t\t// ( I - J^-1 * J ) * restPose\n\t\t\t\tconst restPose = matrixPool.get( freeDoF, 1 );\n\t\t\t\tconst restPoseResult = matrixPool.get( freeDoF, 1 );\n\t\t\t\tlet colIndex = 0;\n\t\t\t\tfor ( let i = 0, l = freeJoints.length; i < l; i ++ ) {\n\n\t\t\t\t\tconst joint = freeJoints[ i ];\n\t\t\t\t\tconst lockedDoFCount = this.lockedJointDoFCount.get( joint ) || 0;\n\t\t\t\t\tconst isLocked = lockedDoFCount !== 0;\n\t\t\t\t\tconst lockedDoF = this.lockedJointDoF.get( joint );\n\n\t\t\t\t\tconst colCount = joint.rotationDoFCount + joint.translationDoFCount - lockedDoFCount;\n\t\t\t\t\tif ( joint.restPoseSet ) {\n\n\t\t\t\t\t\tconst dofList = joint.dof;\n\t\t\t\t\t\tconst dofValues = joint.dofValues;\n\t\t\t\t\t\tconst dofRestPose = joint.dofRestPose;\n\t\t\t\t\t\tfor ( let d = 0; d < colCount; d ++ ) {\n\n\t\t\t\t\t\t\tconst dof = dofList[ d ];\n\n\t\t\t\t\t\t\tif ( isLocked && lockedDoF[ dof ] ) continue;\n\n\t\t\t\t\t\t\trestPose[ colIndex ][ 0 ] = dofRestPose[ dof ] - dofValues[ dof ];\n\t\t\t\t\t\t\tcolIndex ++;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tfor ( let d = 0; d < colCount; d ++ ) {\n\n\t\t\t\t\t\t\trestPose[ colIndex ][ 0 ] = 0;\n\t\t\t\t\t\t\tcolIndex ++;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// J^-1 * J\n\t\t\t\tconst jij = matrixPool.get( freeDoF, freeDoF );\n\t\t\t\tmat.multiply( jij, pseudoInverse, jacobian );\n\n\t\t\t\t// ( I - J^-1 * J )\n\t\t\t\tconst ident = matrixPool.get( freeDoF, freeDoF );\n\t\t\t\tmat.identity( ident );\n\n\t\t\t\tconst nullSpaceProjection = matrixPool.get( freeDoF, freeDoF );\n\t\t\t\tmat.subtract( nullSpaceProjection, ident, jij );\n\n\t\t\t\t// ( I - J^-1 * J ) * restPose\n\t\t\t\tmat.multiply( restPoseResult, nullSpaceProjection, restPose );\n\n\t\t\t\tfor ( let r = 0; r < freeDoF; r ++ ) {\n\n\t\t\t\t\tconst val = restPoseResult[ r ][ 0 ];\n\t\t\t\t\tdeltaTheta[ r ][ 0 ] += val * restPoseFactor;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// Check if our joints have not moved and returned stalled\n\t\t\tif ( stallThreshold > 0 ) {\n\n\t\t\t\tlet stalled = true;\n\t\t\t\tfor ( let i = 0, l = deltaTheta.length; i < l; i ++ ) {\n\n\t\t\t\t\tconst delta = deltaTheta[ i ][ 0 ];\n\t\t\t\t\tif ( Math.abs( delta ) > stallThreshold ) {\n\n\t\t\t\t\t\tstalled = false;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( stalled ) {\n\n\t\t\t\t\tstatus = SOLVE_STATUS.STALLED;\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// Prep for a divergence check\n\t\t\tprevDoFValues.forEach( ( dofValues, joint ) => {\n\n\t\t\t\tdofValues.set( joint.dofValues );\n\n\t\t\t} );\n\n\t\t\t// apply the latest joint angles and lock and joints that have\n\t\t\t// hit their joint limits.\n\t\t\tthis.applyJointAngles( freeJoints, deltaTheta );\n\n\t\t\t// there's still error and we're under the max iterations\n\n\t\t} while ( true );\n\n\t\ttargetJoints.length = 0;\n\t\tfreeJoints.length = 0;\n\t\treturn status;\n\n\t}\n\n\t// Apply the delta values from the solve to the free joints in the list\n\tapplyJointAngles( freeJoints, deltaTheta ) {\n\n\t\tconst {\n\t\t\tlockedJointDoF,\n\t\t\tlockedJointDoFCount,\n\t\t} = this;\n\n\t\tlet lockedJoint = false;\n\t\tlet dti = 0;\n\t\tfor ( let i = 0, l = freeJoints.length; i < l; i ++ ) {\n\n\t\t\t// Apply the delta to every free joint\n\t\t\tconst joint = freeJoints[ i ];\n\t\t\tconst dofList = joint.dof;\n\t\t\tconst lockedDoF = lockedJointDoF.get( joint );\n\t\t\tconst isLocked = lockedJointDoFCount.has( joint );\n\n\t\t\tfor ( let d = 0, l = dofList.length; d < l; d ++ ) {\n\n\t\t\t\tconst dof = dofList[ d ];\n\t\t\t\tif ( isLocked && lockedDoF[ dof ] ) {\n\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\tconst value = joint.getDoFValue( dof );\n\t\t\t\tconst hitLimit = joint.setDoFValue( dof, value + deltaTheta[ dti ][ 0 ] );\n\n\t\t\t\t// lock the joint if we hit a limit\n\t\t\t\tif ( hitLimit ) {\n\n\t\t\t\t\tif ( ! lockedJointDoFCount.has( joint ) ) {\n\n\t\t\t\t\t\tlockedJointDoFCount.set( joint, 0 );\n\t\t\t\t\t\tlockedDoF.fill( 0 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst lockedCount = lockedJointDoFCount.get( joint );\n\t\t\t\t\tlockedJointDoFCount.set( joint, lockedCount + 1 );\n\t\t\t\t\tlockedDoF[ dof ] = 1;\n\t\t\t\t\tlockedJoint = true;\n\n\t\t\t\t}\n\n\t\t\t\tdti ++;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( dti !== deltaTheta.length ) {\n\n\t\t\tthrow new Error();\n\n\t\t}\n\n\t\treturn lockedJoint;\n\n\t}\n\n\t// generate the jacobian\n\t// The jacobian has one column for each free degree of freedom and a row for every\n\t// target degree of freedom we have. The entries are generated by adjusting every\n\t// DoF by some epsilon and storing how much it affected the target error.\n\tfillJacobian( targetJoints, freeJoints, outJacobian ) {\n\n\t\tconst {\n\t\t\ttranslationStep,\n\t\t\trotationStep,\n\t\t\tlockedJointDoF,\n\t\t\tlockedJointDoFCount,\n\t\t\ttranslationFactor,\n\t\t\trotationFactor,\n\t\t} = this;\n\n\t\t// TODO: abstract this\n\t\tconst affectedClosures = this.affectedClosures;\n\t\tconst affectedConnectedClosures = this.affectedConnectedClosures;\n\n\t\tlet colIndex = 0;\n\t\tfor ( let c = 0, tc = freeJoints.length; c < tc; c ++ ) {\n\n\t\t\t// TODO: If this is a goal we should skip adding it to the jacabian columns\n\t\t\tconst freeJoint = freeJoints[ c ];\n\t\t\tconst relevantClosures = affectedClosures.get( freeJoint );\n\t\t\tconst relevantConnectedClosures = affectedConnectedClosures.get( freeJoint );\n\t\t\tconst dofList = freeJoint.dof;\n\t\t\tconst colCount = freeJoint.translationDoFCount + freeJoint.rotationDoFCount;\n\n\t\t\tconst isLocked = lockedJointDoFCount.has( freeJoint );\n\t\t\tconst lockedDoF = lockedJointDoF.get( freeJoint );\n\n\t\t\t// get the world inverse of the free joint\n\t\t\tmat4.invert( tempInverseMatrixWorld, freeJoint.matrixWorld );\n\n\t\t\t// iterate over every degree of freedom in the joint\n\t\t\tfor ( let co = 0; co < colCount; co ++ ) {\n\n\t\t\t\tconst dof = dofList[ co ];\n\n\t\t\t\t// skip this joint if it's locked\n\t\t\t\tif ( isLocked && lockedDoF[ dof ] ) {\n\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\tlet rowIndex = 0;\n\n\t\t\t\t// generate the adjusted matrix based on the epsilon for the joint.\n\t\t\t\tlet delta = dof < 3 ? translationStep : rotationStep;\n\t\t\t\tif ( freeJoint.getDeltaWorldMatrix( dof, delta, tempDeltaWorldMatrix ) ) {\n\n\t\t\t\t\tdelta *= - 1;\n\n\t\t\t\t}\n\n\t\t\t\t// Iterate over every target\n\t\t\t\tfor ( let r = 0, tr = targetJoints.length; r < tr; r ++ ) {\n\n\t\t\t\t\tconst targetJoint = targetJoints[ r ];\n\n\t\t\t\t\t// if it's a closure target\n\t\t\t\t\tif ( targetJoint.isClosure ) {\n\n\t\t\t\t\t\tif ( relevantClosures.has( targetJoint ) || relevantConnectedClosures.has( targetJoint ) ) {\n\n\t\t\t\t\t\t\t// TODO: If this is a Goal it only add 1 or 2 fields if only two axes are set. Quat is only\n\t\t\t\t\t\t\t// needed if 3 eulers are used.\n\t\t\t\t\t\t\t// TODO: these could be cached per target joint get the current error within the closure joint\n\n\t\t\t\t\t\t\t// Get the error from child towards the closure target\n\t\t\t\t\t\t\ttargetJoint.getClosureError( tempPos, tempQuat );\n\t\t\t\t\t\t\tif ( relevantConnectedClosures.has( targetJoint ) ) {\n\n\t\t\t\t\t\t\t\t// If this is affecting a link connected to a closure joint then adjust that child link by\n\t\t\t\t\t\t\t\t// the delta rotation.\n\t\t\t\t\t\t\t\tmat4.multiply( targetRelativeToJointMatrix, tempInverseMatrixWorld, targetJoint.child.matrixWorld );\n\t\t\t\t\t\t\t\tmat4.multiply( targetDeltaWorldMatrix, tempDeltaWorldMatrix, targetRelativeToJointMatrix );\n\n\t\t\t\t\t\t\t\t// Get the new error\n\t\t\t\t\t\t\t\tgetMatrixDifference( targetJoint.matrixWorld, targetDeltaWorldMatrix, tempPos2, tempQuat2 );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t// If this is directly affecting a closure joint then adjust that child link by the delta\n\t\t\t\t\t\t\t\t// rotation.\n\t\t\t\t\t\t\t\tmat4.multiply( targetRelativeToJointMatrix, tempInverseMatrixWorld, targetJoint.matrixWorld );\n\t\t\t\t\t\t\t\tmat4.multiply( targetDeltaWorldMatrix, tempDeltaWorldMatrix, targetRelativeToJointMatrix );\n\n\t\t\t\t\t\t\t\t// Get the new error\n\t\t\t\t\t\t\t\tgetMatrixDifference( targetDeltaWorldMatrix, targetJoint.child.matrixWorld, tempPos2, tempQuat2 );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Get the amount that the rotation and translation error changed due to the\n\t\t\t\t\t\t\t// small DoF adjustment to serve as the derivative.\n\t\t\t\t\t\t\tvec3.subtract( tempPos, tempPos, tempPos2 );\n\t\t\t\t\t\t\tvec3.scale( tempPos, tempPos, translationFactor / delta );\n\n\t\t\t\t\t\t\tvec4.subtract( tempQuat, tempQuat, tempQuat2 );\n\t\t\t\t\t\t\tvec4.scale( tempQuat, tempQuat, rotationFactor / delta );\n\n\t\t\t\t\t\t\tif ( targetJoint.isGoal ) {\n\n\t\t\t\t\t\t\t\tconst { translationDoFCount, rotationDoFCount, dof } = targetJoint;\n\t\t\t\t\t\t\t\tfor ( let i = 0; i < translationDoFCount; i ++ ) {\n\n\t\t\t\t\t\t\t\t\tconst d = dof[ i ];\n\t\t\t\t\t\t\t\t\toutJacobian[ rowIndex + i ][ colIndex ] = tempPos[ d ];\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif ( rotationDoFCount === 3 ) {\n\n\t\t\t\t\t\t\t\t\toutJacobian[ rowIndex + translationDoFCount + 0 ][ colIndex ] = tempQuat[ 0 ];\n\t\t\t\t\t\t\t\t\toutJacobian[ rowIndex + translationDoFCount + 1 ][ colIndex ] = tempQuat[ 1 ];\n\t\t\t\t\t\t\t\t\toutJacobian[ rowIndex + translationDoFCount + 2 ][ colIndex ] = tempQuat[ 2 ];\n\t\t\t\t\t\t\t\t\toutJacobian[ rowIndex + translationDoFCount + 3 ][ colIndex ] = tempQuat[ 3 ];\n\t\t\t\t\t\t\t\t\trowIndex += 4;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\trowIndex += translationDoFCount;\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t// set translation\n\t\t\t\t\t\t\t\toutJacobian[ rowIndex + 0 ][ colIndex ] = tempPos[ 0 ];\n\t\t\t\t\t\t\t\toutJacobian[ rowIndex + 1 ][ colIndex ] = tempPos[ 1 ];\n\t\t\t\t\t\t\t\toutJacobian[ rowIndex + 2 ][ colIndex ] = tempPos[ 2 ];\n\n\t\t\t\t\t\t\t\t// set rotation\n\t\t\t\t\t\t\t\toutJacobian[ rowIndex + 3 ][ colIndex ] = tempQuat[ 0 ];\n\t\t\t\t\t\t\t\toutJacobian[ rowIndex + 4 ][ colIndex ] = tempQuat[ 1 ];\n\t\t\t\t\t\t\t\toutJacobian[ rowIndex + 5 ][ colIndex ] = tempQuat[ 2 ];\n\t\t\t\t\t\t\t\toutJacobian[ rowIndex + 6 ][ colIndex ] = tempQuat[ 3 ];\n\t\t\t\t\t\t\t\trowIndex += 7;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// if the target isn't relevant then there's no delta\n\t\t\t\t\t\t\tlet totalRows = 7;\n\t\t\t\t\t\t\tif ( targetJoint.isGoal ) {\n\n\t\t\t\t\t\t\t\ttotalRows = targetJoint.translationDoFCount;\n\t\t\t\t\t\t\t\tif ( targetJoint.rotationDoFCount === 3 ) {\n\n\t\t\t\t\t\t\t\t\ttotalRows += 4;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tfor ( let i = 0; i < totalRows; i ++ ) {\n\n\t\t\t\t\t\t\t\toutJacobian[ rowIndex + i ][ colIndex ] = 0;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\trowIndex += totalRows;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// Check if this joint has a target set and update the jacobian rows if it does\n\t\t\t\t\tif ( targetJoint.targetSet ) {\n\n\t\t\t\t\t\tconst rowCount = targetJoint.translationDoFCount + targetJoint.rotationDoFCount;\n\n\t\t\t\t\t\tif ( freeJoint === targetJoint ) {\n\n\t\t\t\t\t\t\t// if we're just dealing with a target dof joint then there can't be any influence\n\t\t\t\t\t\t\t// but otherwise the only joint that can have an effect on this error is the joint\n\t\t\t\t\t\t\t// itself.\n\t\t\t\t\t\t\t// TODO: Having noted that is this really necessary? Is there any way that this doesn't just\n\t\t\t\t\t\t\t// jump to the solution and lock? How can we afford some slack? With a low weight? Does that\n\t\t\t\t\t\t\t// get applied here?\n\t\t\t\t\t\t\t// TODO: If this joint happens to have three euler joints we need to use a quat here. Otherwise we\n\t\t\t\t\t\t\t// use the euler angles.\n\t\t\t\t\t\t\tfor ( let i = 0; i < rowCount; i ++ ) {\n\n\t\t\t\t\t\t\t\toutJacobian[ rowIndex + colIndex ][ colIndex ] = - 1;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tfor ( let i = 0; i < rowCount; i ++ ) {\n\n\t\t\t\t\t\t\t\toutJacobian[ rowIndex + i ][ colIndex ] = 0;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\trowIndex += rowCount;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tcolIndex ++;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( colIndex !== outJacobian[ 0 ].length ) {\n\n\t\t\tthrow new Error();\n\n\t\t}\n\n\t}\n\n\t// Fill in the error vector\n\tfillErrorVector( targetJoints, errorVector ) {\n\n\t\tlet rowIndex = 0;\n\t\tfor ( let i = 0, l = targetJoints.length; i < l; i ++ ) {\n\n\t\t\tconst joint = targetJoints[ i ];\n\t\t\tif ( joint.isClosure ) {\n\n\t\t\t\taccumulateClosureError( this, joint, rowIndex, errorVector, errorResultInfo );\n\t\t\t\trowIndex += errorResultInfo.rowCount;\n\n\t\t\t}\n\n\t\t\tif ( joint.targetSet ) {\n\n\t\t\t\taccumulateTargetError( this, joint, rowIndex, errorVector, errorResultInfo );\n\t\t\t\trowIndex += errorResultInfo.rowCount;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t// Count the unconverged targets in the chain and store them in targetJoints and store\n\t// any freeJoints in\n\tcountUnconvergedVariables( freeJoints, targetJoints, dofResultInfo ) {\n\n\t\tconst { lockedJointDoFCount } = this;\n\n\t\tconst chain = this.chain;\n\t\tlet totalError = 0;\n\t\tlet errorRows = 0;\n\t\tlet unconvergedRows = 0;\n\t\tlet freeDoF = 0;\n\t\tfor ( let i = 0, l = chain.length; i < l; i ++ ) {\n\n\t\t\tlet addToTargetList = false;\n\t\t\tconst joint = chain[ i ];\n\t\t\tconst lockedDoF = lockedJointDoFCount.get( joint ) || 0;\n\n\t\t\t// TODO: Should we check every variable against the convergence threshold or is\n\t\t\t// it better to check the magnitude?\n\n\t\t\t// TODO: We may be able to speed this up by using the square distance and length\n\t\t\t// to compare error.\n\n\t\t\t// TODO: If this is a goal we shouldnt add to the free dof because they won't be added\n\t\t\t// to the jacobian\n\n\t\t\t// If this is a closure joint then we need to make sure we're solving\n\t\t\t// for the other child end to meet this joint so this error is important.\n\t\t\tif ( joint.isClosure ) {\n\n\t\t\t\taccumulateClosureError( this, joint, errorRows, null, errorResultInfo );\n\t\t\t\tif ( ! errorResultInfo.isConverged ) {\n\n\t\t\t\t\tunconvergedRows += errorResultInfo.rowCount;\n\t\t\t\t\ttotalError += errorResultInfo.totalError;\n\n\t\t\t\t}\n\n\t\t\t\taddToTargetList = true;\n\t\t\t\terrorRows += errorResultInfo.rowCount;\n\n\t\t\t}\n\n\t\t\t// Check out far the joint is from the target dof value.\n\t\t\tconst dofList = joint.dof;\n\t\t\tif ( joint.targetSet ) {\n\n\t\t\t\taccumulateTargetError( this, joint, errorRows, null, errorResultInfo );\n\t\t\t\tif ( ! errorResultInfo.isConverged ) {\n\n\t\t\t\t\tunconvergedRows += errorResultInfo.rowCount;\n\t\t\t\t\ttotalError += errorResultInfo.totalError;\n\n\t\t\t\t}\n\n\t\t\t\taddToTargetList = true;\n\t\t\t\terrorRows += errorResultInfo.rowCount;\n\n\t\t\t}\n\n\t\t\tif ( ! joint.isGoal && dofList.length > 0 ) {\n\n\t\t\t\tfreeDoF += dofList.length - lockedDoF;\n\t\t\t\tfreeJoints.push( joint );\n\n\t\t\t}\n\n\t\t\tif ( addToTargetList ) {\n\n\t\t\t\ttargetJoints.push( joint );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// if it turns out that everything is converged.\n\t\tif ( unconvergedRows === 0 ) {\n\n\t\t\terrorRows = 0;\n\n\t\t}\n\n\t\tdofResultInfo.errorRows = errorRows;\n\t\tdofResultInfo.freeDoF = freeDoF;\n\t\tdofResultInfo.totalError = totalError;\n\n\t}\n\n}\n","import { mat } from './utils/matrix.js';\n\nclass FixedMatrixPool {\n\n\tconstructor( row, col ) {\n\n\t\tconst matrices = [];\n\t\tlet index = 0;\n\n\t\tthis.get = function () {\n\n\t\t\tlet matrix = matrices[ index ];\n\t\t\tif ( ! matrix ) {\n\n\t\t\t\tmatrices[ index ] = matrix = mat.create( row, col );\n\n\t\t\t}\n\n\t\t\tindex ++;\n\t\t\treturn matrix;\n\n\t\t};\n\n\t\tthis.releaseAll = function () {\n\n\t\t\tindex = 0;\n\n\t\t};\n\n\t}\n\n}\n\nexport class MatrixPool {\n\n\tconstructor() {\n\n\t\tconst pools = {};\n\t\tconst poolArray = [];\n\t\tthis.get = function ( row, col ) {\n\n\t\t\tlet colPools = pools[ row ];\n\t\t\tif ( ! colPools ) {\n\n\t\t\t\tcolPools = pools[ row ] = {};\n\n\t\t\t}\n\n\t\t\tlet pool = colPools[ col ];\n\t\t\tif ( ! pool ) {\n\n\t\t\t\tpool = colPools[ col ] = new FixedMatrixPool( row, col );\n\t\t\t\tpoolArray.push( pool );\n\n\t\t\t}\n\n\t\t\treturn pool.get();\n\n\t\t};\n\n\t\tthis.releaseAll = function () {\n\n\t\t\tfor ( let i = 0, l = poolArray.length; i < l; i ++ ) {\n\n\t\t\t\tpoolArray[ i ].releaseAll();\n\n\t\t\t}\n\n\t\t};\n\n\t}\n\n}\n","import { Frame } from './Frame.js';\n\nexport class Link extends Frame {\n\n\tconstructor() {\n\n\t\tsuper();\n\t\tthis.isLink = true;\n\t\tthis.closureJoints = [];\n\n\t}\n\n\taddChild( child ) {\n\n\t\tif ( ! child.isJoint ) {\n\n\t\t\tthrow new Error( 'Link: Added child must be a Joint.' );\n\n\t\t} else {\n\n\t\t\tsuper.addChild( child );\n\n\t\t}\n\n\t}\n\n}\n","import { Joint, DOF } from './Joint.js';\n\nexport class Goal extends Joint {\n\n\tconstructor( ...args ) {\n\n\t\tsuper( ...args );\n\t\tthis.isGoal = true;\n\t\tthis.setFreeDoF();\n\n\t}\n\n\tsetDoF( ...args ) {\n\n\t\t// We don't support rotation goals that only specify 1 or 2 free rotation axes.\n\t\tlet rotCount =\n\t\t\tNumber( args.includes( DOF.EX ) ) +\n\t\t\tNumber( args.includes( DOF.EY ) ) +\n\t\t\tNumber( args.includes( DOF.EZ ) );\n\n\t\tif ( rotCount !== 0 && rotCount !== 3 ) {\n\n\t\t\tthrow new Error( 'Goal: Only full 3 DoF or 0 DoF rotation goals are supported.' );\n\n\t\t}\n\n\t\tsuper.setDoF( ...args );\n\n\t}\n\n\tsetGoalDoF( ...args ) {\n\n\t\tthis.setDoF( ...args );\n\n\t}\n\n\tsetFreeDoF( ...args ) {\n\n\t\tconst freeDoF = [\n\t\t\tDOF.X, DOF.Y, DOF.Z,\n\t\t\tDOF.EX, DOF.EY, DOF.EZ,\n\t\t].filter( d => ! args.includes( d ) );\n\t\tthis.setDoF( ...freeDoF );\n\n\t}\n\n\taddChild() {\n\n\t\tthrow new Error( 'Goal: Cannot add children to Goal.' );\n\n\t}\n\n}\n","export const JOINT_STRIDE = 304;\n\nexport const LINK_STRIDE = 56;\n\nexport function generateSharedBuffer( frames, useSharedArrayBuffer = true ) {\n\n\t// dofValues \t6 * 4\n\t// dofTarget \t6 * 4\n\t// dofRestPose \t6 * 4\n\t// minDoFLimit \t6 * 4\n\t// maxDoFLimit \t6 * 4\n\t// position \t3 * 4\n\t// quaternion \t4 * 4\n\t// targetSet \t1\n\t// restPoseSet \t1\n\t// --\n\t// total  \t\t150 bytes per joint\n\t// 4 byte aligned: 152\n\n\tlet arrayBuffer;\n\tif ( useSharedArrayBuffer ) {\n\n\t\tarrayBuffer = new SharedArrayBuffer( JOINT_STRIDE * frames.length );\n\n\t} else {\n\n\t\tarrayBuffer = new ArrayBuffer( JOINT_STRIDE * frames.length );\n\n\t}\n\n\tconst float64 = new Float32Array( arrayBuffer );\n\tconst byte8 = new Uint8Array( arrayBuffer );\n\tapplyToBuffer( frames, float64, byte8 );\n\treturn arrayBuffer;\n\n}\n\nexport function applyToBuffer( frames, floatBuffer, byteBuffer, copyDoFValues = true, copyJointSettings = true ) {\n\n\tfor ( let i = 0, l = frames.length; i < l; i ++ ) {\n\n\t\tcopyFrameToBuffer( frames[ i ], floatBuffer, byteBuffer, i * JOINT_STRIDE, copyDoFValues, copyJointSettings );\n\n\t}\n\n}\n\nexport function applyFromBuffer( frames, floatBuffer, byteBuffer, copyDoFValues = true, copyJointSettings = true ) {\n\n\tfor ( let i = 0, l = frames.length; i < l; i ++ ) {\n\n\t\tcopyBufferToFrame( frames[ i ], floatBuffer, byteBuffer, JOINT_STRIDE * i, copyDoFValues, copyJointSettings );\n\n\t}\n\n}\n\n// Copy data from the frame to the given buffer starting at the given byte offset. Joints take JOINT_STRIDE\n// bytes while links take LINK_STRIDE bytes.\nexport function copyFrameToBuffer(\n\tframe,\n\tfloatBuffer,\n\tbyteBuffer,\n\tbyteOffset,\n\tcopyDoFValues = true,\n\tcopyJointSettings = true,\n) {\n\n\tconst floatOffset = byteOffset / 4;\n\tif ( copyJointSettings ) {\n\n\t\tconst {\n\t\t\tposition,\n\t\t\tquaternion,\n\t\t} = frame;\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tfloatBuffer[ floatOffset + 0 + i ] = position[ i ];\n\n\t\t}\n\n\t\tfor ( let i = 0; i < 4; i ++ ) {\n\n\t\t\tfloatBuffer[ floatOffset + 3 + i ] = quaternion[ i ];\n\n\t\t}\n\n\t\tif ( frame.isJoint ) {\n\n\t\t\tconst {\n\t\t\t\tdofTarget,\n\t\t\t\tdofRestPose,\n\t\t\t\tminDoFLimit,\n\t\t\t\tmaxDoFLimit,\n\t\t\t\ttargetSet,\n\t\t\t\trestPoseSet,\n\t\t\t} = frame;\n\n\t\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\t\tfloatBuffer[ floatOffset + 7 + 0 * 6 + i ] = dofTarget[ i ];\n\t\t\t\tfloatBuffer[ floatOffset + 7 + 1 * 6 + i ] = dofRestPose[ i ];\n\t\t\t\tfloatBuffer[ floatOffset + 7 + 2 * 6 + i ] = minDoFLimit[ i ];\n\t\t\t\tfloatBuffer[ floatOffset + 7 + 3 * 6 + i ] = maxDoFLimit[ i ];\n\n\t\t\t}\n\n\t\t\tbyteBuffer[ byteOffset + 148 ] = Number( targetSet );\n\t\t\tbyteBuffer[ byteOffset + 149 ] = Number( restPoseSet );\n\n\t\t}\n\n\n\t}\n\n\tif ( copyDoFValues && frame.isJoint ) {\n\n\t\tconst { dofValues } = frame;\n\n\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\tfloatBuffer[ floatOffset + 7 + 4 * 6 + i ] = dofValues[ i ];\n\n\t\t}\n\n\t}\n\n}\n\n// Copy data from the given buffer to the given frame starting at the given byte offset.\nexport function copyBufferToFrame(\n\tjoint,\n\tfloatBuffer,\n\tbyteBuffer,\n\tbyteOffset,\n\tcopyDoFValues = true,\n\tcopyJointSettings = true,\n) {\n\n\tconst floatOffset = byteOffset / 4;\n\n\tif ( copyJointSettings ) {\n\n\t\tjoint.setPosition(\n\t\t\tfloatBuffer[ floatOffset + 0 ],\n\t\t\tfloatBuffer[ floatOffset + 1 ],\n\t\t\tfloatBuffer[ floatOffset + 2 ],\n\t\t);\n\t\tjoint.setQuaternion(\n\t\t\tfloatBuffer[ floatOffset + 3 + 0 ],\n\t\t\tfloatBuffer[ floatOffset + 3 + 1 ],\n\t\t\tfloatBuffer[ floatOffset + 3 + 2 ],\n\t\t\tfloatBuffer[ floatOffset + 3 + 3 ],\n\t\t);\n\n\t\tif ( joint.isJoint ) {\n\n\t\t\tconst {\n\t\t\t\tdofTarget,\n\t\t\t\tdofRestPose,\n\t\t\t\tminDoFLimit,\n\t\t\t\tmaxDoFLimit,\n\t\t\t} = joint;\n\n\t\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\t\tdofTarget[ i ] = floatBuffer[ floatOffset + 7 + 0 * 6 + i ];\n\t\t\t\tdofRestPose[ i ] = floatBuffer[ floatOffset + 7 + 1 * 6 + i ];\n\t\t\t\tminDoFLimit[ i ] = floatBuffer[ floatOffset + 7 + 2 * 6 + i ];\n\t\t\t\tmaxDoFLimit[ i ] = floatBuffer[ floatOffset + 7 + 3 * 6 + i ];\n\n\t\t\t}\n\n\t\t\tjoint.targetSet = Boolean( byteBuffer[ byteOffset + 148 ] );\n\t\t\tjoint.restPoseSet = Boolean( byteBuffer[ byteOffset + 149 ] );\n\n\t\t}\n\n\t}\n\n\tif ( copyDoFValues && joint.isJoint ) {\n\n\t\tconst { dofValues } = joint;\n\t\tlet changed = false;\n\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\tconst v = floatBuffer[ floatOffset + 7 + 4 * 6 + i ];\n\t\t\tif ( v !== dofValues[ i ] ) {\n\n\t\t\t\tdofValues[ i ] = v;\n\t\t\t\tchanged = true;\n\n\t\t\t}\n\n\n\t\t}\n\n\t\t// only update dof matrix if it changed\n\t\tif ( changed ) {\n\n\t\t\tjoint.setMatrixDoFNeedsUpdate();\n\n\t\t}\n\n\t}\n\n}\n","import { Solver } from \"../core/Solver.js\";\nimport { SOLVE_STATUS } from \"../core/ChainSolver.js\";\nimport { deserialize } from \"./serialize.js\";\nimport { applyToBuffer, applyFromBuffer } from \"./utils.js\";\n\nconst useSharedArrayBuffers = typeof SharedArrayBuffer !== \"undefined\";\n\nlet solver = new Solver();\nlet solveHandle = -1;\n\n// List of all frames in the graph\nlet frames = null;\n\n// Buffer variants\nlet buffer = null;\nlet floatBuffer = null;\nlet byteBuffer = null;\n\nglobal.onmessage = function ({ data: e }) {\n  const { type, data } = e;\n  switch (type) {\n    // The ik graph needs to be updated with all the deserialized\n    case \"updateStructure\":\n      frames = deserialize(data.serialized);\n      solver.roots = frames.filter((f) => f.parent === null);\n      solver.updateStructure();\n\n      buffer = data.buffer;\n      byteBuffer = new Uint8Array(buffer);\n      floatBuffer = new Float32Array(buffer);\n      break;\n\n    // update the frame state from buffer when not using shared array buffers\n    case \"updateFrameState\":\n      byteBuffer.set(new Uint8Array(data.buffer));\n      break;\n\n    // Update the settings of the solver\n    case \"updateSolverSettings\":\n      Object.assign(solver, data);\n      break;\n\n    // Start the solve loop\n    case \"startSolve\":\n      if (solveHandle === -1) {\n        updateSolve();\n      }\n\n      break;\n\n    // Stop the solve loop\n    case \"endSolve\":\n      if (solveHandle !== -1) {\n        clearTimeout(solveHandle);\n        solveHandle = -1;\n      }\n\n      break;\n  }\n};\n\n// The iterative solve loop\nfunction updateSolve() {\n  // Copy any frame updates from the main thread\n  applyFromBuffer(frames, floatBuffer, byteBuffer, false, true);\n\n  // Solve 1 iteration taking the most severe chain result\n  const status = solver.solve();\n\n  // Copy the new DoF back to the shared buffer\n  applyToBuffer(frames, floatBuffer, byteBuffer, true, false);\n\n  if (status.find((r) => r === SOLVE_STATUS.TIMEOUT)) {\n    // yield so we can react to messages\n    solveHandle = setTimeout(updateSolve);\n  } else {\n    solveHandle = -1;\n  }\n\n  // send a copy of the buffer back if not using shared array buffers\n  if (useSharedArrayBuffers) {\n    postMessage({\n      type: \"updateSolve\",\n      data: {\n        status,\n      },\n    });\n  } else {\n    const resultsBuffer = buffer.slice();\n    postMessage(\n      {\n        type: \"updateSolve\",\n        data: {\n          status,\n          buffer: resultsBuffer,\n        },\n      },\n      [resultsBuffer]\n    );\n  }\n}\n","import { ChainSolver } from './ChainSolver.js';\nimport { findRoots } from './utils/findRoots.js';\nimport { MatrixPool } from './MatrixPool.js';\n\nexport class Solver {\n\n\tconstructor( roots = [] ) {\n\n\t\tthis.matrixPool = new MatrixPool();\n\n\t\tthis.useSVD = false;\n\n\t\tthis.maxIterations = 5;\n\t\tthis.stallThreshold = 1e-4;\n\t\tthis.dampingFactor = 0.001;\n\t\tthis.divergeThreshold = 0.01;\n\t\tthis.restPoseFactor = 0.01;\n\n\t\tthis.translationConvergeThreshold = 1e-3;\n\t\tthis.rotationConvergeThreshold = 1e-5;\n\n\t\tthis.translationFactor = 1;\n\t\tthis.rotationFactor = 1;\n\n\t\tthis.translationStep = 1e-3;\n\t\tthis.rotationStep = 1e-3;\n\n\t\tthis.translationErrorClamp = 0.1;\n\t\tthis.rotationErrorClamp = 0.1;\n\n\t\tthis.roots = Array.isArray( roots ) ? [ ...roots ] : [ roots ];\n\t\tthis.solvers = null;\n\n\t\tthis.updateStructure();\n\n\t}\n\n\t// needs to be called whenever tree structure is updated\n\tupdateStructure() {\n\n\t\tconst roots = findRoots( this.roots );\n\t\tconst chains = [];\n\t\tconst traversal = new Set();\n\t\tconst allChainJoints = new Set();\n\t\tconst traverseChains = frame => {\n\n\t\t\t// If we found a joint then add it to the traversal list\n\t\t\tif ( frame.isJoint ) {\n\n\t\t\t\tconst joint = frame;\n\t\t\t\ttraversal.add( joint );\n\n\t\t\t\t// If we found a closure joint\n\t\t\t\tif ( joint.isClosure ) {\n\n\t\t\t\t\t// Traverse back up the tree until we find a common ancestor\n\t\t\t\t\t// and create a new chain\n\t\t\t\t\tconst chainSet = new Set();\n\t\t\t\t\tlet curr = joint.child;\n\t\t\t\t\twhile ( curr ) {\n\n\t\t\t\t\t\tif ( curr.isJoint ) {\n\n\t\t\t\t\t\t\tif ( traversal.has( curr ) ) {\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tchainSet.add( curr );\n\t\t\t\t\t\t\t\tallChainJoints.add( curr );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcurr = curr.parent;\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttraversal.forEach( c => {\n\n\t\t\t\t\t\tchainSet.add( c );\n\t\t\t\t\t\tallChainJoints.add( c );\n\n\t\t\t\t\t} );\n\t\t\t\t\tchains.push( chainSet );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// Continue traversing\n\t\t\tconst children = frame.children;\n\t\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\t\ttraverseChains( children[ i ] );\n\n\t\t\t}\n\n\t\t\t// Remove the joint from our traversal set\n\t\t\ttraversal.delete( frame );\n\n\t\t};\n\n\t\t// find all chains in the roots\n\t\troots.forEach( traverseChains );\n\n\t\t// Merge interdependent chains\n\t\tconst independentChains = [];\n\t\twhile ( chains.length ) {\n\n\t\t\tconst currChain = chains.pop();\n\t\t\tindependentChains.push( currChain );\n\t\t\tfor ( let i = 0; i < chains.length; i ++ ) {\n\n\t\t\t\t// see if this chain is dependent on the current chain\n\t\t\t\t// and if so merge the chains.\n\t\t\t\tconst otherChain = chains[ i ];\n\n\t\t\t\tlet dependent = false;\n\t\t\t\totherChain.forEach( c => {\n\n\t\t\t\t\tdependent = dependent || currChain.has( c );\n\n\t\t\t\t} );\n\n\t\t\t\tif ( dependent ) {\n\n\t\t\t\t\totherChain.forEach( c => currChain.add( c ) );\n\t\t\t\t\tchains.splice( i, 1 );\n\t\t\t\t\ti --;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Find any joints that aren't considered part of a solve chain so we\n\t\t// can just update them using forward kinematics.\n\t\tconst nonChainJoints = new Set();\n\t\troots.forEach( root => root.traverse( c => {\n\n\t\t\tif ( c.isJoint && c.dof.length > 0 && ! allChainJoints.has( c ) ) {\n\n\t\t\t\tnonChainJoints.add( c );\n\n\t\t\t}\n\n\t\t} ) );\n\n\t\t// Create the solvers for the chains\n\t\tthis.solvers = independentChains.map( c => new ChainSolver( c ) );\n\t\tthis.nonChainJoints = nonChainJoints;\n\n\t}\n\n\tsolve() {\n\n\t\tconst { solvers, nonChainJoints } = this;\n\n\t\t// update any non chain joints\n\t\tnonChainJoints.forEach( joint => {\n\n\t\t\tif ( joint.targetSet ) {\n\n\t\t\t\tjoint.dofValues.set( joint.dofTarget );\n\t\t\t\tjoint.setMatrixDoFNeedsUpdate();\n\n\t\t\t}\n\n\t\t} );\n\n\t\tconst results = [];\n\t\tfor ( let i = 0, l = solvers.length; i < l; i ++ ) {\n\n\t\t\tconst s = solvers[ i ];\n\t\t\ts.matrixPool = this.matrixPool;\n\n\t\t\ts.useSVD = this.useSVD;\n\n\t\t\ts.maxIterations = this.maxIterations;\n\t\t\ts.stallThreshold = this.stallThreshold;\n\t\t\ts.dampingFactor = this.dampingFactor;\n\t\t\ts.divergeThreshold = this.divergeThreshold;\n\t\t\ts.restPoseFactor = this.restPoseFactor;\n\n\t\t\ts.translationConvergeThreshold = this.translationConvergeThreshold;\n\t\t\ts.rotationConvergeThreshold = this.rotationConvergeThreshold;\n\n\t\t\ts.translationFactor = this.translationFactor;\n\t\t\ts.rotationFactor = this.rotationFactor;\n\n\t\t\ts.translationStep = this.translationStep;\n\t\t\ts.rotationStep = this.rotationStep;\n\n\t\t\ts.translationErrorClamp = this.translationErrorClamp;\n\t\t\ts.rotationErrorClamp = this.rotationErrorClamp;\n\n\t\t\tconst result = s.solve();\n\t\t\tresults.push( result );\n\n\t\t}\n\n\t\treturn results;\n\n\t}\n\n}\n","export function findRoots( frames ) {\n\n\tconst potentialRoots = frames.map( f => {\n\n\t\tlet lastParent = f;\n\t\tf.traverseParents( p => {\n\n\t\t\tlastParent = p;\n\n\t\t} );\n\t\treturn lastParent;\n\n\t} );\n\tconst roots = [];\n\tconst set = new Set();\n\n\tfor ( let i = 0; i < potentialRoots.length; i ++ ) {\n\n\t\tconst frame = potentialRoots[ i ];\n\n\t\t// If this frame has already been traversed then we know it's in\n\t\t// a root already.\n\t\tif ( set.has( frame ) ) {\n\n\t\t\tcontinue;\n\n\t\t}\n\n\t\troots.push( frame );\n\t\tframe.traverse( c => {\n\n\t\t\tif ( set.has( c ) ) {\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t\tset.add( c );\n\n\t\t\t// If we come across a joint or link with closures traverse them\n\t\t\t// as far as possible to add them to the roots if they haven't been\n\t\t\t// added already.\n\t\t\tlet closureConnections;\n\t\t\tif ( c.isLink ) {\n\n\t\t\t\tclosureConnections = c.closureJoints;\n\n\t\t\t} else if ( c.isJoint && c.isClosure ) {\n\n\t\t\t\tclosureConnections = [ c.child ];\n\n\t\t\t}\n\n\t\t\tif ( closureConnections ) {\n\n\t\t\t\tclosureConnections.forEach( cl => {\n\n\t\t\t\t\tlet lastParent = cl;\n\t\t\t\t\tcl.traverseParents( p => {\n\n\t\t\t\t\t\tlastParent = p;\n\n\t\t\t\t\t} );\n\n\t\t\t\t\tif ( ! set.has( lastParent ) ) {\n\n\t\t\t\t\t\tpotentialRoots.push( lastParent );\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t} );\n\n\t}\n\n\treturn roots;\n\n}\n","import { Joint } from '../core/Joint.js';\nimport { Link } from '../core/Link.js';\nimport { Goal } from '../core/Goal.js';\n\n// Takes a list of interconnected frames and serializes them into a non cyclic json representation\nexport function serialize( frames ) {\n\n\tconst map = new Map();\n\tconst info = [];\n\n\t// Create the initial frame list along with a joint -> index map\n\tfor ( let i = 0, l = frames.length; i < l; i ++ ) {\n\n\t\tconst frame = frames[ i ];\n\n\t\tconst {\n\t\t\tname,\n\t\t\tdof,\n\t\t\tdofValues,\n\t\t\tdofTarget,\n\t\t\tdofRestPose,\n\t\t\tminDoFLimit,\n\t\t\tmaxDoFLimit,\n\t\t\ttargetSet,\n\t\t\trestPoseSet,\n\t\t\tposition,\n\t\t\tquaternion,\n\t\t\tisClosure,\n\t\t} = frame;\n\n\t\tlet type = 'Link';\n\t\tif ( frame.isGoal ) {\n\n\t\t\ttype = 'Goal';\n\n\t\t} else if ( frame.isJoint ) {\n\n\t\t\ttype = 'Joint';\n\n\t\t}\n\n\t\tconst res = {\n\t\t\tdof: dof ? dof.slice() : null,\n\t\t\tdofValues: dofValues ? dofValues.slice() : null,\n\t\t\tdofTarget: dofTarget ? dofTarget.slice() : null,\n\t\t\tdofRestPose: dofRestPose ? dofRestPose.slice() : null,\n\t\t\tminDoFLimit: minDoFLimit ? minDoFLimit.slice() : null,\n\t\t\tmaxDoFLimit: maxDoFLimit ? maxDoFLimit.slice() : null,\n\t\t\ttargetSet,\n\t\t\trestPoseSet,\n\t\t\tisClosure,\n\n\t\t\tname,\n\t\t\tposition: position.slice(),\n\t\t\tquaternion: quaternion.slice(),\n\t\t\tchildren: null,\n\t\t\tclosureJoints: null,\n\t\t\tchild: null,\n\t\t\ttype,\n\t\t};\n\n\t\tinfo.push( res );\n\t\tmap.set( frame, i );\n\n\t}\n\n\t// Create the child and parent index references.\n\tfor ( let i = 0, l = frames.length; i < l; i ++ ) {\n\n\t\tconst inf = info[ i ];\n\t\tconst frame = frames[ i ];\n\t\tinf.children = frame.children.map( c => map.get( c ) );\n\t\tif ( frame.isLink ) {\n\n\t\t\tinf.closureJoints = frame.closureJoints.map( c => map.get( c ) );\n\n\t\t}\n\n\t\tif ( frame.isJoint && frame.child ) {\n\n\t\t\tinf.child = map.get( frame.child );\n\n\t\t}\n\n\t\tif ( frame.parent ) {\n\n\t\t\tinf.parent = map.get( frame.parent );\n\n\t\t} else {\n\n\t\t\tinf.parent = null;\n\n\t\t}\n\n\t}\n\n\treturn info;\n\n}\n\n// Deserialize the serialized representation of the graph\nexport function deserialize( data ) {\n\n\t// Create joints / links for every serialized version\n\tconst frames =\n\t\tdata.map( d => {\n\n\t\t\tconst {\n\t\t\t\ttype,\n\t\t\t\tname,\n\t\t\t\tposition,\n\t\t\t\tquaternion,\n\n\t\t\t\tdof,\n\t\t\t\tdofValues,\n\t\t\t\tdofTarget,\n\t\t\t\tdofRestPose,\n\t\t\t\tminDoFLimit,\n\t\t\t\tmaxDoFLimit,\n\t\t\t\ttargetSet,\n\t\t\t\trestPoseSet,\n\t\t\t\tisClosure,\n\t\t\t} = d;\n\n\t\t\tlet frame;\n\t\t\tswitch ( type ) {\n\n\t\t\t\tcase 'Goal':\n\t\t\t\tcase 'Joint':\n\t\t\t\t\tframe = type === 'Goal' ? new Goal() : new Joint();\n\n\t\t\t\t\tframe.setDoF( ...dof );\n\t\t\t\t\tframe.dofValues.set( dofValues );\n\t\t\t\t\tframe.dofTarget.set( dofTarget );\n\t\t\t\t\tframe.dofRestPose.set( dofRestPose );\n\t\t\t\t\tframe.minDoFLimit.set( minDoFLimit );\n\t\t\t\t\tframe.maxDoFLimit.set( maxDoFLimit );\n\n\t\t\t\t\tframe.targetSet = targetSet;\n\t\t\t\t\tframe.restPoseSet = restPoseSet;\n\t\t\t\t\tframe.isClosure = isClosure;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'Link':\n\t\t\t\t\tframe = new Link();\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tframe.name = name;\n\t\t\tframe.position.set( position );\n\t\t\tframe.quaternion.set( quaternion );\n\t\t\treturn frame;\n\n\t\t} );\n\n\t// set the parent and child from the maps\n\tfor ( let i = 0; i < frames.length; i ++ ) {\n\n\t\tconst frame = frames[ i ];\n\t\tconst info = data[ i ];\n\n\t\tframe.parent = frames[ info.parent ] || null;\n\t\tframe.children.push( ...info.children.map( i => frames[ i ] ) );\n\t\tframe.setMatrixNeedsUpdate();\n\n\t\tif ( frame.isLink ) {\n\n\t\t\tframe.closureJoints.push( ...info.closureJoints.map( i => frames[ i ] ) );\n\n\t\t}\n\n\t\tif ( frame.isJoint ) {\n\n\t\t\tframe.child = info.child !== null ? frames[ info.child ] : null;\n\t\t\tframe.setMatrixDoFNeedsUpdate();\n\n\t\t}\n\n\t}\n\n\treturn frames;\n\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n// the startup function\n__webpack_require__.x = () => {\n\t// Load entry module and return exports\n\t// This entry module depends on other loaded chunks and execution need to be delayed\n\tvar __webpack_exports__ = __webpack_require__.O(undefined, [555], () => (__webpack_require__(151)))\n\t__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n\treturn __webpack_exports__;\n};\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.f = {};\n// This file contains only the entry chunk.\n// The chunk loading function for additional chunks\n__webpack_require__.e = (chunkId) => {\n\treturn Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {\n\t\t__webpack_require__.f[key](chunkId, promises);\n\t\treturn promises;\n\t}, []));\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.u = (chunkId) => {\n\t// return url for filenames based on template\n\treturn \"\" + chunkId + \".js\";\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","var scriptUrl;\nif (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + \"\";\nvar document = __webpack_require__.g.document;\nif (!scriptUrl && document) {\n\tif (document.currentScript)\n\t\tscriptUrl = document.currentScript.src\n\tif (!scriptUrl) {\n\t\tvar scripts = document.getElementsByTagName(\"script\");\n\t\tif(scripts.length) scriptUrl = scripts[scripts.length - 1].src\n\t}\n}\n// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration\n// or pass an empty string (\"\") and set the __webpack_public_path__ variable from your code to use your own logic.\nif (!scriptUrl) throw new Error(\"Automatic publicPath is not supported in this browser\");\nscriptUrl = scriptUrl.replace(/#.*$/, \"\").replace(/\\?.*$/, \"\").replace(/\\/[^\\/]+$/, \"/\");\n__webpack_require__.p = scriptUrl;","// no baseURI\n\n// object to store loaded chunks\n// \"1\" means \"already loaded\"\nvar installedChunks = {\n\t151: 1\n};\n\n// importScripts chunk loading\nvar installChunk = (data) => {\n\tvar [chunkIds, moreModules, runtime] = data;\n\tfor(var moduleId in moreModules) {\n\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t}\n\t}\n\tif(runtime) runtime(__webpack_require__);\n\twhile(chunkIds.length)\n\t\tinstalledChunks[chunkIds.pop()] = 1;\n\tparentChunkLoadingFunction(data);\n};\n__webpack_require__.f.i = (chunkId, promises) => {\n\t// \"1\" is the signal for \"already loaded\"\n\tif(!installedChunks[chunkId]) {\n\t\tif(true) { // all chunks have JS\n\t\t\timportScripts(__webpack_require__.p + __webpack_require__.u(chunkId));\n\t\t}\n\t}\n};\n\nvar chunkLoadingGlobal = self[\"webpackChunkrv\"] = self[\"webpackChunkrv\"] || [];\nvar parentChunkLoadingFunction = chunkLoadingGlobal.push.bind(chunkLoadingGlobal);\nchunkLoadingGlobal.push = installChunk;\n\n// no HMR\n\n// no HMR manifest","// run startup\nvar __webpack_exports__ = __webpack_require__.x();\n"],"sourceRoot":""}